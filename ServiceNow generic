Body HTML template:

<div class="custom-backdrop fade" ng-class="{'in modal-backdrop':c.showAllSelectedReservables}" style="z-index:10"> </div> 
<div class="wsd-search container-fluid" ng-class="{'edit-mode': c.isEditing, 'wsd-mesp-wrapper': c.isNative}">
 <div class="row padding-0 no-box-shadow" ng-if="c.validRSVData">
    <div class="margin-top-24">
      <h1 id="reservationHeading" class="reservation-heading">{{::c.title}}</h1>
      <p class="reservation-info-text">{{::c.subTitle}}</p>
    </div>
	
    <wsd-search-filter id="wsdSearchFilter"
                       mode="c.mode"
                       location-tree-data="c.data.location_tree_data"
                       reservation="c.reservation"
                       start="c.start"
                       end="c.end"
                       day-start="c.data.dayStart"
                       day-end="c.data.dayEnd"
                       page-size="c.options.page_size"
                       init-config="::c.data.initSearchConfig"
                       is-multi-item-selection="c.selectedItems.length > 1"
                       disable-change-location="c.isChangeLocationDisabled()"
                       disable-change-module="c.isEditing || c.selectedItems.length >= 1"
                       types = "c.data.reservable_modules"
                       translations = "c.data.translations"
                       c = "c">
    </wsd-search-filter>
  </div>
	<div class="row info-container margin-top-24 padding-24 results-container panel panel-wrapper result-container-btm-margin" ng-if="c.data.reservable_modules.length > 0">
		<div id="notificationWrapper" class="notification-wrapper" ng-if="c.showNotification">
			<wsd-notification
				notification-config="c.notificationConfig"
				show-notification="c.showNotification">
			</wsd-notification>
		</div>
		<!-- Suggestions-->
		<div class="no-recommendations-pane row" ng-if="c.validRSVData && !c.searching && !c.wasSearched && !c.hasError">
			<div class="center-block text-align-center">
				<div class="no-recommendation-icon">
					<i aria-hidden="true" class="fa fa-meh-o"></i>
				</div>
			</div>
			<div class="center-block text-align-center ">
				<p class="no-recommendation-header-text">
					${No recommended reservations yet}
				</p>
			</div>
			<div class="center-block text-align-center">
				<p class="no-recommendation-body-text">
					${Once we have an idea of what you are looking for, we will suggest some of your favorite places and things to reserve.}
				</p>
			</div>
		</div>
		<!-- Search results-->
		<div class="row result-header" ng-if="c.wasSearched && c.activeView">
      <!-- Building strip -->
      <div id="buildingStrip" class="col-md-12" ng-if="c.showBuildingStrip()">
        <div class="building-strip col-md-12">
          <div id="multiBuildingRow" class="row">
            <span class="scroll-chevron chevron-left" ng-if="c.canScrollLeft || c.canShowScrollForBuildingStrip('left')">
              <button aria-label="Scroll left" class="btn btn-default scroll-btn-secondary btn-round btn-scroll-left"
                      href="javascript:void(0)" ng-click="c.scrollBuildingStrip('left')">
                <i class="fa fa-chevron-left"></i>
              </button>
            </span>
            <div id={{item.building.value}}
                 class="b r-2x building-card" 
                 ng-class="{'current-search-building':  item.building.value == c.selectedBuildingToSearch.value}" 
                 ng-repeat="item in c.searchBuildingList track by $index"
                 aria-label="{{item.building.value == c.selectedBuildingToSearch.value ? 
                             '${Search results available for }' + ' '+ item.building.displayValue + ' '+ item.building.campusName + ' ' + item.countLabel :
                             '${Select }' + item.building.displayValue + ' '+ item.building.campusName + ' '+ item.countLabel + ' ' +'${ to search for available spaces}'
                             }}"
                 ng-click="c.searchFromBuildingStrip($index)" tabindex="0">
                    <h5 class="text-overflow-ellipsis no-margin mb-6"><b>{{item.building.displayValue}}</b></h5>
                    <div class="text-overflow-ellipsis mb-6">{{item.building.campusName}}</div>
                    <div class="text-overflow-ellipsis">{{item.countLabel}}</div>
            </div>
            <span class="scroll-chevron chevron-right" ng-if="c.canScrollRight || c.canShowScrollForBuildingStrip('right')">
              <button aria-label="Scroll right" class="btn btn-default scroll-btn-secondary btn-round btn-scroll-right"
                      href="javascript:void(0)" ng-click="c.scrollBuildingStrip('right')">
                <i class="fa fa-chevron-right"></i>
              </button>
            </span>
          </div>
        </div>
      </div>
      <div class="col-md-12 seperator" ng-if="c.searchBuildingList.length>1" ><hr class="divider"></div>
			<div class="col-md-12 col-xs-12 header-padding-bottom">
				<h2 class="name result-title first-letter-cap" ng-if="!c.searchWasAuto">${Search results}</h2>
				<div ng-if="c.searchWasAuto" class="auto-search-result-title">
					<h2 class="h4">${Find what's available for you}</h2>
					<p class="auto-search-result-sub-title">{{c.autoSearchResultSubTitle}}</p>
				</div>
        
       <div class="searching-loader" 
             ng-if="(c.searching && !(c.activeView.type === 'map' && c.mapType==c.MAP_TYPE.INDOOR_MAPS)) ||
                    (c.searchBuildingList.length < 1 && c.wasSearched)">
         <div class="loader-progress-bar">
         </div>
        </div>
        <div ng-if="!c.searching && c.mappedReservables.length > 0">
					<p id="showing-results" class="showing-results" aria-live="assertive">${Showing {{c.mappedReservables.length}} results}</p>
				</div>
        
			</div>
			<div class="col-xs-12">
				<div class="result-wrapper row flex-row">
					<div class="col-md-4 col-xs-12">
						<div class="filter-and-sort row flex-row">
							<div class="col-xs-12 header-padding-bottom">
								<h3 ng-show="c.mappedReservables.length > 0 || !c.isRegularSearch" class="filter-title h4">
									<a ng-click="c.toggleReservableFilter()"
                     ng-keypress="c.checkKey($event)"
                     id="wsd-filter-button"
									   href="javascript:void(0)"
									   role="button"
									   class="brand-primary"
									   aria-label="{{c.showReservableFilter ? '${Reservable filter expanded}' : '${Reservable filter collapsed}'}}">
										<i class="fa fa-filter" aria-hidden="true"></i>{{!c.showReservableFilter ? '${Show filters}' : '${Hide filters}' + ' (' + c.filterCount + ')'}}
									</a>
								</h3>
							</div>
						</div>
					</div>
					<div role="navigation" class="tab-navigation col-md-8 col-xs-12 flex-row justify-end header-padding-bottom">
						<label for="sortBySelect"
							class="sort-by-label m-n"
							title="${View}">
							${View}
						</label>
						<div ng-if="c.renderSortBy"
							id="sortBySelect"
							select2
							select2-options="c.sortBySelect2Options"
							ng-model="c.sortBy"
							ng-change="c.onSortByChange()"
							class="view-dropdown"
							disabled="c.sortByDisabled">
						</div>
						<span	id="viewOption_{{$index}}"
							class="view-toggle text-overflow-ellipsis"
							ng-if="c.viewOptions && !c.data.isMesp"
							ng-class="{'active': c.activeView.type === viewOpt.type}"
							ng-click="c.toggleViewOption(viewOpt)"
							ng-repeat="viewOpt in c.viewOptions | orderBy: viewOpt.order"
							ng-attr-title="{{::viewOpt.label}}"
							aria-label="{{ c.activeView.type === viewOpt.type ? viewOpt.label + ' ${selected}' : viewOpt.label }}"
							ng-attr-aria-description="{{viewOpt.type === 'map' ? c.mapViewTabDesc : ''}}"
							tabindex="0">
							<i class="fa {{::viewOpt.iconClass}}"></i>{{::viewOpt.label}}
						</span>
					</div>
				</div>
			</div>
		</div>
		<!-- searching indicator -->
    <div class="searching-loader" 
         ng-if="(c.searching && !(c.activeView.type === 'map' && c.mapType==c.MAP_TYPE.INDOOR_MAPS)) ||
                (c.searchBuildingList.length < 1 && c.wasSearched)">
      <div class="cards-overlay">
        <div class="loading-text-cards">
          <div class="fa fa-spinner fa-spin spinner-margin" aria-hidden="true" name="spinner" spin="true"></div>
          <div>
            ${Just a moment while we load the results}
          </div>
        </div>
      </div>
    </div>
		<div class="notification-wrapper availability-update" ng-if="c.editInfo">
			<div id="notificationInEditMode" class="alert" ng-class="c.editInfo.hasAvailabilityError ? 'alert-warning' : 'alert-info'" role="alert">
				<i class="fa" ng-class="c.editInfo.hasAvailabilityError ? 'fa-exclamation-triangle' : 'fa-info-circle'" aria-hidden="true"></i>&nbsp;&nbsp;
				{{c.editInfo.msg}}
				<strong>
					<u><a id="undoChangesAndBackToReservation" href ng-click="c.undoChangesAndBackToReservation()" role="button" aria-label="{{ c.editInfo.msg + ' ${Click to undo}' }}">{{c.editInfo.actionText}}</a></u>
				</strong>
			</div>
		</div>
		<div ng-hide="c.searchBuildingList.length < 1" class="result-records" ng-class="{row: c.showReservableFilter}">
			<!-- reservable filter -->
			<div class="col-md-3 reservable-filter-wrapper"
           ng-if="(!c.searching && c.wasSearched)"
			     ng-class="{'m-t-xl': c.showReservableFilter && ['schedule'].indexOf(c.activeView.type) >= 0 && c.mappedReservables.length > 0}"
			     ng-show="c.showReservableFilter && (c.mappedReservables.length > 0 || !c.isRegularSearch)">
				<!-- We need to reset the reservalbe filter when we step into map view from other tabs -->
				<wsd-reservable-filter></wsd-reservable-filter>
			</div>
			<!-- card view -->
			<div ng-class="{'col-md-9': c.showReservableFilter && c.activeView.type === 'card'}" ng-if="!c.searching && c.wasSearched">
				<div class="card-view row card-view-container" ng-if="c.activeView.type === 'card' && c.mappedReservables.length > 0">
					<div class="col-sm-6 col-xs-12 width-transition margin-bottom-20"
						 ng-class="c.showReservableFilter ? 'col-md-6' : 'col-md-4'"
					     ng-repeat="item in c.mappedReservables track by item.sys_id">
						<wsd-horizontal-card
							id="{{item.sys_id}}"
							favorite-widget="item.favoriteWidget"
							identifiers="item.tags"
							extra-data="item"
							image="item.image"
							title="{{::item.name}}"
							sub-title="{{::item.subtitle}}"
							metadata="item.body"
							actions="item.cardActions"
							actions-callback="c.cardActionsCallback"
							css-class="horizontal-card"
							aria-controls="itemsInfo",
              availability-score="item.availabilityScore"
							>
						</wsd-horizontal-card>
          </div>
				</div>
			</div>
			<!-- ELSE: schedule view -->
			<div ng-class="{'col-md-9': c.showReservableFilter && c.activeView.type === 'schedule'}" ng-if="!c.searching && c.wasSearched">
				<div class="schedule-view" ng-if="c.activeView.type === 'schedule' && c.mappedReservables.length > 0">
					<wsd-schedule-view
            			primary-building-tz="c.prBuildingTz"
            			secondary-building-tz="c.secBuildingTz"
						start="c.scheduleViewStart"
						end="c.scheduleViewEnd"
						reservables="c.mappedReservables"
						disable-reserve-single="c.isMultiItemSelection"
						disable-reserve-multi="(c.isOccurrence || c.isRecurring) && c.isAnyItemSelected"
						reserve-reservable="c.reserveReservable(sys_id)"
						toggle-reservable-selection="c.toggleReservableSelection(item, event)"
						total-steps="c.scheduleViewTotalStep"
						sort-by="c.sortBy"
						display-rsv-card="true"
						aria-controls="itemsInfo"
						is-favorites-enabled="c.data.isFavoritesEnabled"
            schedule-view-date="c.scheduleViewDate"
            display-start="c.scheduleViewDisplayDate.startDisplayDate"
            display-end="c.scheduleViewDisplayDate.endDisplayDate"
            reservable-filter-expanded="c.showReservableFilter">
					</wsd-schedule-view>
				</div>
			</div>
      <!-- ELSE: map view -->
      <div ng-class="{'col-md-9': c.showReservableFilter && c.activeView.type === 'map' && !c.searching && c.wasSearched , 'col-md-12' : c.searching && !c.wasSearched}">
        <div class="map-view" ng-if="c.mapType==c.MAP_TYPE.MAPPEDIN && c.activeView.type === 'map'">
          <wsd-mappedin-map
                            ng-if="c.showMap"
                            map-config="c.mappedinConfig"
                            mappedin-map-data="c.wsdMappedinReservationData"
                            on-space-select="c.onMapSpaceSelect"
                            templates="c.wsdMappedinTemplates"
                            on-floor-change="c.mountWsdMappedinComponent"/>
        </div>
        <div class="map-view indoor-map-container" ng-if="c.mapType==c.MAP_TYPE.INDOOR_MAPS" ng-show="c.activeView.type === 'map' && !c.missingSpaceMap">
        <div ng-class="{'map-overlay' : c.wsdIndoorMapObject.isMapwizeLoading}" ng-if="c.wsdIndoorMapObject.isMapwizeLoading">
            <div class="loading-text">
              <div class="fa fa-spinner fa-spin spinner-margin" aria-hidden="true" name="spinner" spin="true"></div>
              <div>
                  ${Just a moment while we load the map}
              </div>
            </div>
          </div>
        <div class="map-view indoor-map-container">
          <wsd-indoor-map
                          map-options="c.indoorMapConfig"
                          on-map-load="c.onIndoorMapLoad"
                          on-map-event="c.onMapEvent"
                          on-reset-view-click="c.onResetViewClick"
                          legends="c.legends"
                          floor-selector-options="c.floorSelectorOptions"
                          building-selector-options="c.buildingSelectorOptions"
                          on-building-selector-change="c.onBuildingSelectorChange"
                          card-template = "c.indoorMapCardTemplate"
                          card-data="c.cardData"
                          pattern-enabled="c.patternEnabled"
						  on-pattern-enabled-change="c.onPatternEnabledChange"
                          place-styles="c.placeStyles"
                          display-user-names-on-map="c.displayUserNamesOnMap"
                          >
          </wsd-indoor-map>
          </div>
      </div>       
        
			<!-- load more action -->
			<div class="load-more-wrapper text-align-center" ng-if="!c.searching && c.wasSearched && c.hasMore && c.activeView && c.activeView.type !== 'map'">
				<button id="showMore" class="btn btn-show-more" ng-click="c.loadMore()">
					${Show more}
				</button>
			</div>
			<!-- no results pane -->
			<div class="no-results-pane"
			     ng-class="{'col-md-9': c.showReservableFilter && c.mappedReservables.length > 0}"
			     ng-if="c.wasSearched && !c.searching && ((c.activeView && c.activeView.type !== 'map' && c.mappedReservables.length <= 0))">
				<div class="center-block text-align-center">
					<div class="no-result-icon">
						<i aria-hidden="true" class="fa fa-search"></i>
					</div>
				</div>
				<div class="center-block text-align-center" aria-live="polite">
					<p id="noSearchResultsHeader" class="no-result-header-text">
						{{c.resultMsg.title}}
					</p>
				</div>
				<div class="center-block text-align-center">
					<p id="noSearchResultsMsg" class="no-result-body-text">
						{{c.resultMsg.msg}}
					</p>
				</div>
			</div>
			<!-- no map pane -->
			<div class="no-results-pane"
					ng-class="{'col-md-9': c.showReservableFilter && c.mappedReservables.length > 0}"
	   			ng-if="c.activeView.type === 'map' && c.missingSpaceMap && c.wasSearched && !c.searching">
				<div class="center-block text-align-center">
					<div class="no-result-icon">
						<i aria-hidden="true" class="fa fa-search"></i>
					</div>
				</div>
				<div class="center-block text-align-center ">
					<p class="no-result-header-text">
						${Map not available}
					</p>
				</div>
				<div class="center-block text-align-center">
					<p class="no-result-body-text">
							${A map is not currently available for this building or floor.}
					</p>
				</div>
			</div>
		</div>
	</div>
	<div class="selected-items-bar" ng-show="c.isAnyItemSelected && !c.searchBuildingList.length < 1" ng-class="{'show-selected-items-bar': c.isAnyItemSelected}">
		<div class="container">
			<div class="bottom-drawer">
				<div class="col-xs-8 col-sm-10 col-md-10 selected-items-container padding-left-27">
					<div class="selected-items-label">
            <span role="region" id="itemsInfo" aria-live="polite" class="padding-right">${{{c.selectedItems.length}} items selected}</span>
            
            <strong><u><a id="unselectAll" href ng-click="c.unSelectAll()" role="button" aria-label="${Unselect all selections}">${Unselect all}</a></u></strong>
					</div>
					<div class="pills-container">
            <div class="selected-pill" ng-repeat="item in c.selectedItems | limitTo: (c.showAllSelectedReservables ? c.selectedItems.length : 4) track by item.sys_id">
             <div class="pill-details"> 
               <h6 class="ellipsis-text pill-header"> {{item.name}} </h6>
               <p class="ellipsis-text pill-content"> {{item.building.display_value}} &#x2022; {{item.campus.display_value}}</p>
              </div>
              <div class="pull-right">
                <span role="button" title="Remove" ng-click="c.removeSelectedItem(item.sys_id, item);" aria-label="Remove {{item.name}}" tabindex="0">
                	<i class="icon-cross text-xs text-muted font-thin" aria-hidden="true"></i>
            		</span>
              </div>
            </div>
            <div class="reservable-count-section" ng-show="c.selectedItems.length > 4" ng-if="!c.showAllSelectedReservables">
              <p class="reservable-count">${+}{{c.selectedItems.length - 4}} ${more}</p>
              <a id="showMoreSelectedReservables" type="button" 
                 style="cursor:pointer; padding-top:5px;" 
                 href="javascript:void(0)"
                 ng-click="c.showAllSelectedReservables=!c.showAllSelectedReservables;"
                 tabindex="0">
                <span>${Show more}</span>
              </a> 
            </div>
            <div class="reservable-count-section" ng-if="c.showAllSelectedReservables">
              <a id="showLessSelectedReservables" type="button" 
                 style="cursor:pointer; padding-top:5px;"  
                 href="javascript:void(0)"
                 ng-click="c.showAllSelectedReservables=!c.showAllSelectedReservables;"
                 tabindex="0">
                <span>${Show less}</span>
              </a> 
            </div>
					</div>
				</div>
				<div class="col-xs-2 padding-right-27">
					<button id="next-btn"
						class="btn btn-primary btn-next pull-right pull-bottom"
						ng-disabled="!c.canSubmitReservation"
						aria-label="${Next}"
						ng-click="c.reserveReservables()">
						${Next}
					</button>
				</div>
			</div>
		</div>
	</div>
  <script type="text/ng-template" id="map-rsv-popup.html">
    <div class="card-view">
      <wsd-reservable-card
        image-size="ctrl.options.thumbnail_size"
        disable-reserve-single="ctrl.isMultiItemSelection"
        disable-reserve-multi="ctrl.isOccurrence"
        reserve-reservable="ctrl.reserveReservable(space.sys_id)"
        toggle-reservable-selection="ctrl.toggleReservableSelection(space, event)"
        reservable="space"
        extras="extras"
      >
      </wsd-reservable-card>
    </div>
  </script>
  
  <script type="text/ng-template" id="rsv-vertical-map-card.html">
    <div class="wsd-indoor-map-card">
      <wsd-vertical-card
        class="wsd-vertical-card-height"
        id = "{{sysId}}"
        title="{{title}}"
        sub-title="{{subtitle}}"
        actions="actions"
        image = "image"
        identifiers = "identifiers"
        favorite = "favorite"
        metadata = "metaData"
        extra-data = "extraData"
        item-type="${Space details}"
        on-close-click="onCardClose"
        actions-callback="actionsCallback">
      </wsd-vertical-card>
    </div>
  </script>
  <script type="text/ng-template" id="map-rsv-popup.html">
    <div class="card-view map-card">
      <wsd-horizontal-card
				id="{{space.sys_id}}"
				identifiers="space.tags"
				extra-data="space"
				image="space.image"
				favorite="space.favorite"
				title="{{::space.name}}"
				sub-title="{{::space.subtitle}}"
				metadata="space.metadata"
				actions="space.cardActions"
				actions-callback="ctrl.cardActionsCallback"
				css-class="{{space.cssClass}}"
				>
      </wsd-horizontal-card>
    </div>
  </script>
</div>

CSS:

$color-white: #fff;
$background-primary: #FFFFFF !default;
$font-size-xs: 12px !default;
$color-very-light-gray: #f6f7f7;
$color-light-gray: #e6e8ea;
$color-gray: #bdc0c4;
$brand-primary: #1f8476 !default;
$brand-primary-lighter: #B8E0D7 !default;
//changed this to legacy portal color because brand-primary-lightest is not defined in Mesp
$brand-primary-lightest: #EEF8F8 !default;
$brand-primary-darker: #333579 !default;

$border-primary: #8790A1 !default;
$card-title-color: $color-white !default;
$icon-dark: #2e2e2e !default;
$outline-color: $brand-primary !default;
$color-negative-dark: #64201a !default;
$box-shadow-color: rgba(94, 94, 94, 0.2) !default;
$background-gray: $color-gray !default;
$background-secondary: #f2f3f5 !default;
$background-light-gray: $background-secondary;
$background-item-unavailable: rgba(228, 228, 228, 0.6) !default;
$input-border: 1px solid $color-gray !default;
$input-border-focus-color: $brand-primary !default;
$input-border-focus: 1px solid $input-border-focus-color !default;
$light-border: 1px solid #e6e8ea !default;
$gray-border: 1px solid $color-gray !default;
$highligh-border: 1px solid $brand-primary;
$image-background-placeholder-color: #293e40 !default;
$highlighted-label-color: #bbd8ed !default;
$filter-border-color: #ddd !default;
$color-placeholder: #a9a9a9 !default;
$font-weight-bold: 600 !default;
$alert-default-border:$border-primary;
$alert-default-bg: #F0F1F5 !default;

$slider-background: rgba($brand-primary,0.3) !default;
$slider-pin-border: 1px solid $brand-primary !default;
$slider-pin-shadow: 0 0px 1px 2px rgba(0, 134, 117, 0.3) !default;
$slider-pin-color: $color-white;

$wsd-slider-inactive-background: $color-gray !default;
$wsd-slider-active-background: $brand-primary !default;
$wsd-slider-button-color: $color-white;

$day-selector-selected-background: $brand-primary !default;
$day-selector-selected-background-hover: #0f3e37 !default;
$day-selector-background: #fff;

$gantt-row-background-hover: rgba($brand-primary-lighter, 0.3);
$gantt-grid-color: $color-light-gray !default;
$gantt-details-top: 60px;
$reserved-gantt-background: repeating-linear-gradient(-55deg, #fff, #fff 7px, #cccccc 6px, #cccccc 10px) !default;
$color-gantt-subtitle: #4a4a4a !default;
$color-gantt-selected-mark: #1F8476 !default;

$item-selected-mark-border: 2px solid $color-white;
$selected-items-bar-background: #fff;
$text-primary: null !default;
$text-secondary: #474D5A !default;
$light-gray: #D4D4D4;
$text-teritiary: #454D5B;

@if $text-primary == null {
    // This CSS will be applied only to the legacy portal
    .panel-wrapper {
        border: 1px solid $light-gray;
        border-radius: $border-radius-large;
        background: $panel-bg;
    }
} @else {
  .esc-portal-overrides{
    .btn-plus, .btn-minus {
    	width: 36px;
    	height: 36px;
		}
  }
  
  .availability-score{
      height: 182px !important;
    }
  @media (min-width: 992px){
    .availability-score{
      height: 122px !important;
    }
  }
  
}

.mapContainer {
    .legend_container {

        &.legend_container_expanded {
            border: 1px solid $brand-primary;
        }

        .legend_label {
            color: $brand-primary;
        }

        .legend_title_expanded {
            background: $brand-primary;

            .legend_label {
                color: $color-white;
            }
        }
    }
}

.arrow-hide {
  color:transparent;
}

.brand-primary {
  color:$brand-primary;
}

.date-border{
	
    box-sizing: border-box;
    width: 82px;
    height: 22px;
    padding-top: 2px;
    padding-bottom: 2px;
    font-size: 11px;
    line-height: 17px;
    color: #161B1C;
    text-align: center;
}

.alert-default {
    background: $alert-default-bg;

    border: 1px solid $border-primary;
    box-sizing: border-box;
    border-radius: 3px;
}

.no-padding {
    padding: 0;
}

.no-margin {
    margin: 0;
}

.no-border-bottom {
    border-bottom: 0 !important;
}

.card-view-thumbnail {
    border: 0px;
    border-bottom: $light-border;
    border-radius: 0px;
}

.highlighted-label {
    display: inline-block;
    padding: 2px 5px;
    margin-right: 4px;
    background-color: $highlighted-label-color;
    border-radius: 3px;
    font-size: 12px;
}

.text-bold {
    font-weight: $font-weight-bold;
}

.line-height-30 {
    line-height: 30px;
}

.line-clamp {
    display: -webkit-box;
    -webkit-line-clamp: 2;
    -webkit-box-orient: vertical;
}

.text-80 {
    font-size: 80%;
}

.first-letter-cap:first-letter {
    text-transform: capitalize
}

.width-transition {
    -webkit-transition: width ease 0.2s;
    -moz-transition: width ease 0.2s;
    -o-transition: width ease 0.2s;
    -ms-transition: width ease 0.2s;
    transition: width ease 0.2s;
}

.btn, .action {
    -webkit-transition: all ease 0.2s;
    -moz-transition: all ease 0.2s;
    -o-transition: all ease 0.2s;
    -ms-transition: all ease 0.2s;
    transition: all ease 0.2s;
}

.bg-light-gray {
    background: $background-light-gray;
}

.require-whole-day-banner {
    margin:24px 20px;
}

.hide-element{
    visibility:hidden;
}

.wsd-search {
    margin: 0 0 20px;

    .search-filter-title {
        margin-top: 30px;
        font-weight: 600;
    }

    .tooltip-inner {
        max-width: 250px;
        text-align: center;
        white-space: pre-wrap;
    }
}

.search-fields-container {
    .notification-wrapper {
        margin: 24px;
    }
}

.number-occurences{
    display:block;
    font-size: $font-size-xs;
    font-weight: 400;
    color : $text-secondary;
}

.search-label {
    margin-top: 5px;
    margin-bottom: 0;
}

.search-button-padding {
  padding-right: 6px;
}

.auto-search-result-title {
    display: flex;
    align-items: baseline;

    .auto-search-result-sub-title {
        padding-left: 1em;
    }
}

.showing-results {
    font-size: 16px;
    font-weight: 400;
    color: $text-secondary;
    font-style: normal;
}

.padding-0 {
    padding: 0px !important;
}

.p-t-10 {
    padding-top:10px;
}

.p-t-16 {
    padding-top:16px;
}

/* This is to handle esc portal */
.wsd-search > .row {
    background: transparent;
}

/* This is to handle esc portal */
.no-box-shadow {
    box-shadow: unset !important;
}

.results-container {
    background-color: $background-primary !important;
    border: 0.1rem solid $light-border !important;
}

.search-filter {
    .row > * {
        padding-bottom: 12px;
    }

    .button {
        margin-top: 18px;
        padding: 6px;
        width: 100%;
        background-color: $brand-primary;
        color: $body-bg;
    }

    .is-invalid {
        .select2-choice,
        #sp_formfield_ {
        	border-color: $alert-danger-border;
        }
    }

    .filter-extra-details {
        background: $background-light-gray;
        padding: 10px 0;
        margin-top: 5px;
        border-radius: 4px;
      	width: 100%;
    }

    .all-day-selection {
        padding-bottom:2px;
    }

    .edit-mode {
        padding-top: 15px;
    }
  
  
    .error-msg {
      color: $brand-danger;
      font-style: italic;
    }
  
    .another-building {
      float:left;
      width:100%;
      
      
      .building-delete-icon {
        display:inline-block;
        margin-left: 20px;
        
        .delete-icon {
          padding: 5px 0px;
          
          a {
            font-size:16px;
            color:$text-primary;
          }
        }
      }
    }
  
  .add-more-building {
    margin-top:16px;
  }
}

.btn-plus, .btn-minus {
    width: 34px;
    height: 34px;
}

.result-title {
  margin-top:12px;
}

@media (max-width: 767px) {
    .filter-and-sort {
        flex-direction: column-reverse;
    }
}

@media (max-width: 991px) {
    .result-wrapper {
        flex-direction: column-reverse;
    }

    .search-filter .button {
        margin-top: 10px;
    }

    .auto-search-result-title {
        display: initial;

        .auto-search-result-sub-title {
            padding-left: 0px;
        }
    }
}

.notification-wrapper {
    margin: 7px 0;
}

.search-notification {
    margin-top: 10px;
    margin-bottom: 15px;
}

.result-header {
    .filter-title {
        color: $brand-primary;
        font-size: $font-size-base;

        i {
            margin-right: 10px;
        }
    }

    .view-toggle {
        padding: 6px 14px;
        display: inline-block;
        border: $gray-border;
        border-color: $brand-primary;
        //border-radius: 2px;
        text-align: center;
        color: $brand-primary;
      
        .fa {
            margin-right: 10px;
        }
        &:first-of-type {
            border-top-left-radius: 4px;
            border-bottom-left-radius: 4px;
        }
        &:last-of-type {
            border-top-right-radius: 4px;
            border-bottom-right-radius: 4px;
        }

        &:nth-of-type(2),
        &:nth-of-type(3) {
            border-left: none;
        }

        &.active {
            background: $brand-primary;
            color: $color-white;
        }
    }
}

.header-padding-bottom {
    padding-bottom: 10px;
}

.result-records {
    margin: 10px 0 0 0;

    .unavailable {
        opacity: 0.6;
        background: $background-item-unavailable;
    }

    .load-more-wrapper {
        margin-bottom: 0px;
    }

    .btn-show-more {
        color: $brand-primary;
        background-color: $background-primary;
        border: none;
        outline: none;
        font-size: $font-size-base;
		&:hover {
			color: $link-hover-color;
		}
    }
  
  .reservable-filter-wrapper{
    padding: 0;
    .wsd-reservable-filter{
      .panel-body{
        padding: $sp-space--sm $sp-space--lg;
         #clearAllFilters{
          position: absolute;
          right: 15px;
        }
      }
      .list-group-item{
        background: none;
      }
    }
  }

}

.card-view, .schedule-view {
    .is-reserved {
        border-color: $brand-primary;
    }

    .selected-mark {
        padding: 0px;
        color: #fff;
        width: 22px;
        height: 22px;
        text-align: center;
        border: $item-selected-mark-border;
        border-radius: 50%;

        &.is-selected {
            background-color: $brand-primary;
        }

        &:focus {
            border-color: $brand-primary;
        }
    }

    .btn[disabled], .is-reserved .btn[disabled] {
        background: $color-gray;
        color: initial;

        &.is-selected.selected-mark {
            background-color: $brand-primary;
            color: #fff;
            opacity: .5;
        }
    }
}

.wsd-reservable-filter {
    .panel-body {
        padding-top: 8px;
        padding-bottom: 8px;

        i {
            position: relative;
            top: 1px;
            padding-left: 8px;
        }
    }

    .filter-item {
        position: relative;
        border-top: 1px solid $filter-border-color;

        .panel-body {
            border-bottom: 1px solid $filter-border-color;
        }

        a {
            position: absolute;
            top: 8px;
            right: 8px;
        }
    }

    .filter-item-capacity {
        .list-group {
            padding: 10px 15px;
        }
    }

    .list-group {
        margin-bottom: 0;
        max-height: 200px;
        overflow-y: auto;
    }

    .list-group-item {
        border: 0;
        padding-bottom: 0;

        .checkbox {
            margin: 0;
        }
    }

    .list-group-item:last-of-type {
        padding-bottom: 10px;
    }
}

@media (min-width: 992px) and (max-width: 1199px){
    .wsd-reservable-filter{
	.filter-item {
		a {
		    left: 20rem;
		    overflow: hidden;
		    white-space: nowrap;
		    text-overflow: ellipsis;
        	    position: absolute;
  
		  }
	        }
	     }
}


@media (min-width: 1200px) and (max-width: 2000px){
    .wsd-reservable-filter{
	.filter-item {
		a {
		    overflow: hidden;
		    white-space: nowrap;
		    text-overflow: ellipsis;
        	    width: 45px;
       	            position: absolute;
	         }
	      }
	   }
}

.tab-navigation {
    align-items: center;

    .sort-by-label {
        padding-right: 10px;
		white-space: nowrap;
    }

    .view-dropdown {
        flex: 40% 0 1;
    }

    .view-toggle {
        flex: 30% 0 1;

        &:first-of-type {
            margin-left: 10px;
        }
    }
}

.card-view {
    .reservable-card {
        overflow: hidden;

        &:focus{
            outline: none;
            border: 1px solid $outline-color !important;
        }

        &:hover {
            outline: none;
            border: 1px solid $outline-color !important;
        }

        .subtitle {
            color: $card-title-color;
            font-weight: 400;
        }

        .item-content {
            position: relative;
            height: 194px;
            padding: 10px;
            color: $icon-dark;

            .description {
                height: 40px;
                max-height: 40px;
                overflow: hidden;
            }

            .title {
                margin-bottom: 5px;
            }

            .text-value  {
                line-height: 16px;
            }

            .btn-container {
                position: absolute;
                width: 100%;
                bottom: 10px;
                left: 0;
            }
        }

        .name {
            color: $card-title-color;
            margin-top: 5px;
            margin-bottom: 0;
            font-weight: 600;
        }

        .image-placeholder {
            max-height: 170px;
            height: 170px;
            position: relative;

            .item-header__info {
                position: absolute;
                top: 0;
                left: 0;
                width: 100%;
                height: 46px;
                z-index: 20;
            }

            .selected-mark {
                position: absolute;
                right: 10px;
                top: 10px;
                -webkit-box-shadow: 0 0 3px 1px #c3c3c3;
                -moz-box-shadow: 0 0 3px 1px #c3c3c3;
                box-shadow: 0 0 3px 1px #c3c3c3;
            }

            .gradient {
                width: 100%;
                height: 50%;
                position: absolute;
                bottom: 0;
                left: 0;
                display: flex;
                flex-direction: column-reverse;
                padding: 10px;
            }

            .image {
                width: 100%;
                height: 100%;
                background-color: $image-background-placeholder-color;
                background-size: cover;
                border-radius: 3px;
            }
        }

        .info-block {
            max-height: 40px;
            margin-bottom: 10px;

            div {
                float: left;
            }

            .reservable-icon {
                width: 20px;
                margin-right: 6px;
            }

            .reservable-value {
                overflow: hidden;
                width: calc(100% - 26px);
            }

            .tooltip-inner {
                text-align: left;
                white-space: pre-wrap;
            }
        }

        .info-block:last-child {
            margin-bottom: 0;
        }

        .highlighted-label {
            position: relative;
            top: 10px;
            left: 10px;
        }
    }
}

.schedule-view {
    position: relative;
    overflow: hidden;
    padding-bottom: $gantt-details-top;
    margin-bottom: 15px;

    .schedule-row {
        overflow: hidden;
    }

    .schedule-col {
        padding: 0;
    }

    .drawing-canvas {
        position: relative;
        display: block;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
    }

    .grid-container {
        display: flex;
    }

    .schedule-overlay {
        position: absolute;
        top: 0;
        left: 0;
        bottom: 0;
        right: 0;
        background: transparent;
      
      	.left-chevron {
          	height: 60px; 
          	margin-top: 30px;	
          	padding-right: 30px;
      	}
      	.right-chevron{
          	height: 60px; 
          	margin-top: 30px;
          	padding-left: 30px;
      	}

        .time-action {
            margin: 0 25px;
        }

        .time-grid {
            position: relative;
            background: transparent;

            .slider-wrapper {
                position: absolute;
                top: $gantt-details-top;
                left: 0;
                bottom: 0;
                min-width: 1px;

                .slider-top {
                    .slider-pin {
                        position: absolute;
                        top: -6px;
                        width: 15px;
                        height: 15px;
                        border: 1px solid #233e40;
                        border-radius: 50%;
                        box-shadow: $slider-pin-shadow;
                        background-color: $slider-pin-color;
                        z-index: 110;
                    }
                }

                .slider-body {
                    position: absolute;
                    top: 0;
                    height: 100%;
                    background: $slider-background;
                    z-index: 20;
                    pointer-events: none; /* enables mouse through, to view what's beneath it */

                    &.overlap-right { border-right: 3px solid $brand-primary; }
                    &.overlap-left { border-left: 3px solid $brand-primary; }
                }
            }

            .time-scale {
                height: 30px;

                .grid-header {
                    display: inline-block;
                    position: absolute;
                    top: 0;
                }
            }

            .time-grid-block-wrapper {
                position: relative;
                top: 0;
                border-left: 2.0px solid $border-primary;
              	overflow: hidden;
              
              	.time-grid-block-thick {
                    position: absolute;
                    top: 0;
                    left: 0;
                    bottom: 0;
                    width: 1px;
                    border-right: 2.0px solid $border-primary;
                }

                .time-grid-block {
                    position: absolute;
                    top: 0;
                    left: 0;
                    bottom: 0;
                    width: 1px;
                    border-right: .5px solid $gantt-grid-color;
                }
            }
        }

        .schedule-col {
            height: 100%;
        }
    }

    .schedule-details {
        position: relative;
        top: $gantt-details-top;
        overflow: hidden;
        width: 100%;
    }

    .shift-left {
        padding-right: 4px;
    }

    .shift-right {
        padding-left: 4px;
    }

    .row--item {
        margin: 0;
        padding: 0;
        position: relative;
        transition: all 0.2s ease;
        border: $light-border;
        border-top-color: transparent;
        margin-top: -1px;

        &:nth-of-type(1) {
            border-top-color: $color-light-gray;
            margin-top: 0;
        }


        .favorite-button {
            background:transparent;
        }

        &:hover {
            background-color: $gantt-row-background-hover;
            border-color: $brand-primary;
        }

        &.is-reserved {
            border: 1px solid $brand-primary;
            background-color: $gantt-row-background-hover;

            .schedule-col {
                &.col-left {
                    border-left: 6px solid $brand-primary;
                }
            }

            .btn-reserve { margin-top: 25px; }
        }

        &.is-reserved.unavailable {
            background: $background-item-unavailable;
        }

        .subtitle {
            font-weight: 300;
            font-size: 90%;
            color: $color-gantt-subtitle;
        }

        .schedule-col {
            height: 135px;

            &.col-left 	{
                padding: 8px;

                & > .item-info > div:not(:last-child) {
                    margin: 0 0 5px 0;
                }
            }

            &.col-left-pad {
                padding: 10px 7px 0px 8px !important;
                margin-bottom: 10px !important;

                & > .item-info > div:not(:last-child) {
                    margin: 0 0 5px 0;
                }
            }

            &.col-right { padding: 10px; border-left: $light-border; }

            &.col-middle {
                .drawing-canvas {
                    position: absolute;
                    bottom: 0;
                    top: auto;
                }
            }
        }
      	
      	.availability-score{
            height: 160px;
        }
      
        .gantt {
            width: 100%;
            bottom: 0;
            height: 20px;

            .reserved {
                position: absolute;
                left: 0;
                top: 0;
                background: $reserved-gantt-background;
                min-width: 1px;
                display: block;
                height: 100%;
                border: $light-border;
            }
        }

        .selected-mark {
            position: absolute;
            left: 0px;
            top: 25px;
            border-color: $brand-primary;

            &:focus {
                -webkit-box-shadow: 0 0 4px 2px $brand-primary;
                -moz-box-shadow: 0 0 4px 2px $brand-primary;
                box-shadow: 0 0 4px 2px $brand-primary;
            }

            &.btn[disabled] {
                border-color: $color-gray;

                &.is-selected {
                    border-color: $brand-primary;
                }
            }
        }

        .btn-reserve {
            margin-top: 16px;
        }

        .btn-add {
            border-color: $brand-primary;
            display: inline-block;
            width: auto;
            padding-left: 8px;
            padding-right: 8px;

            .btn-label-reserve {
                color: $brand-primary;
            }


            &:hover {
                outline: none;
                box-shadow:none;
            }

            &:focus:not(:focus-visible){
                outline: none;
                box-shadow:none;
            }
            &:focus-visible{
                -webkit-box-shadow: 0 0 4px 0 $brand-primary;
                -moz-box-shadow: 0 0 4px 0 $brand-primary;
                box-shadow: 0 0 4px 0 $brand-primary;

            }

        }

        .btn-remove {
            border-color: $brand-primary;
            background-color: $color-light-gray;

            &:focus:not(:focus-visible){
                outline: none;
                box-shadow:none;
            }
            &:focus-visible{
                -webkit-box-shadow: 0 0 4px 0 $brand-primary;
                -moz-box-shadow: 0 0 4px 0 $brand-primary;
                box-shadow: 0 0 4px 0 $brand-primary;

            }
            &:hover {
                outline: none;
                border: 1px solid $outline-color !important;
            }
        }

        .reservable-action { display: inline-grid; }
    }

    .reservable-details {
        padding-top: 2px;

        div:not(:last-child) {
            margin-bottom: 5px;
        }
    }

    .reservable-icon {
        margin-right: 4px;
    }

    .pull-right {
        margin-top: -4px !important;
    }
  	
  .availabilityScore-scheduleView{
    display: flex;
    padding-top: 5px; 
  }
  
  .availabilityText-scheduleView{
    padding-left: 6px;
    color: $text-teritiary;
    font-style: normal;
    font-weight: 400;
    line-height: 20px; 
  }
  
  .availability-icon{
    font-size: 20px;
  }
  
}

.card-view, .schedule-view {
    .icon {
        margin: 0 5px 0 5px;
        font-size: 105%;

        &:first-child {
            margin-left: 0;
        }

        &:last-child {
            margin-right: 0;
        }
    }

    .reservable-title {
        font-weight: 600;
    }
}

.no-recommendations-pane {
    height: 100%;
    padding-top: 10px;
    padding-bottom: 30px;

    .no-recommendation-icon {
        align-content: center;
        font-size: 50px;
    }

    .no-recommendation-header-text {
        font-weight: bold;
    }

    .no-recommendation-body-text {
        margin-top: 20px;
    }

}

.no-results-pane {
    height: 100%;
    padding-top: 10px;
    padding-bottom: 30px;

    .no-result-icon {
        align-content: center;
        font-size: 50px;
    }

    .no-result-header-text {
        font-weight: bold;
    }

    .no-result-body-text {
        margin-top: 20px;
    }
}

.text-ellipses {
    white-space: nowrap;
    overflow: hidden;
    text-overflow: ellipsis;
}


.text-align-center {
    text-align: center;
}

.text-align-right {
    text-align: right;
}

.gradient-transparent-black{
    background-image: linear-gradient(rgba(0,0,0,0), rgba(0,0,0,0.9));
}


.align-center{
    flex-direction:column;
    align-items:flex-start;
    justify-content:center;
  	display:flex;
}


/** for checkbox input component **/
.checkbox-wrapper {
    /* Base for label styling */
    [type="checkbox"]:not(:checked),
    [type="checkbox"]:checked {
        position: absolute;
        left: 0;
        opacity: 0.01;
    }

    [type="checkbox"]:not(:checked) + label,
    [type="checkbox"]:checked + label {
        position: relative;
        padding-left: 24px;
        line-height: 1.2;
        cursor: pointer;
    }

    /* checkbox */
    [type="checkbox"]:not(:checked) + label:before,
    [type="checkbox"]:checked + label:before {
        content: '';
        position: absolute;
        left: 0;
        top: 0;
        width: 16px;
        height: 16px;
        border: 1px solid $color-gray;
        border-radius: 3px;
        box-shadow: inset 0 1px 3px rgba(0,0,0, .1), 0 0 0 rgba(183, 183, 183, .2);
        -webkit-transition: all .275s;
        transition: all .275s;
    }

    /* checked mark icon */
    [type="checkbox"]:checked + label:before {
        background: $brand-primary;
    }

    [type="checkbox"]:not(:checked) + label:after,
    [type="checkbox"]:checked + label:after {
        font-family: 'FontAwesome';
        content: '\f00c';
        position: absolute;
        top: 8px;
        left: 3px;
        font-size: 10px;
        color: $color-white;
        line-height: 0;
        -webkit-transition: all .2s;
        transition: all .2s;
    }

    /* checked mark aspect changes */
    [type="checkbox"]:not(:checked) + label:after {
        opacity: 0;
        -webkit-transform: scale(0) rotate(45deg);
        transform: scale(0) rotate(45deg);
    }

    [type="checkbox"]:checked + label:after {
        opacity: 1;
        -webkit-transform: scale(1) rotate(0);
        transform: scale(1) rotate(0);
    }

    /* Disabled  */
    [type="checkbox"]:disabled:not(:checked) + label:before,
    [type="checkbox"]:disabled:checked + label:before {
        box-shadow: none;
        border-color: $color-gray;
        background-color: rgba($brand-primary, .25);
    }

    [type="checkbox"]:disabled:checked + label:after {
        color: $color-lightest;
    }

    [type="checkbox"]:disabled + label {
        color: #aaa;
    }

    /* Accessibility */
 /*   [type="checkbox"]:checked:focus + label:before,
    [type="checkbox"]:not(:checked):focus + label:before {
        box-shadow: inset 0 1px 2px rgba(0,0,0, .1), 0 0 0 2px rgba(183, 183, 183, .2);
        -webkit-box-shadow: inset 0 1px 2px rgba(0,0,0, .1), 0 0 0 2px rgba(183, 183, 183, .2);
        border: 1px solid $input-border-focus-color;
        outline: 5px auto $input-border-focus-color;
    } */
  
    [type="checkbox"]:checked:focus + label:before,
    [type="checkbox"]:not(:checked):focus + label:before {
        box-shadow: 0 0 0.8rem $brand-primary;
        border: 2px solid $color-white;
        outline: 1px solid $input-border-focus-color;
    }
}

////// wsd-select-wrapper, used to make a select look like sn-record-picker
.wsd-select-wrapper > select {
    -webkit-appearance: none;
    -moz-appearance: none;
    text-indent: 1px;
    text-overflow: '';
}

.wsd-select-wrapper > select {
    box-sizing: border-box;
    -webkit-box-sizing: border-box;
    -moz-box-sizing: border-box;
    padding-left: 8px;
    width: 100%;
    background: $color-white;
    color: #000;
    border: 1px solid $color-gray;
    border-radius: 4px;
    -webkit-appearance: none;
    -moz-appearance: none;
    appearance: none;
    font-size: .9em;
    line-height: 32px;
    text-decoration: none;
    border-radius: 4px;
    background-clip: padding-box;
}

.wsd-select-wrapper > select:focus {
    outline: 5px auto $input-border-focus-color;
    border-color: $input-border-focus-color;
    box-shadow: 0 0 5px $input-border-focus-color;
    outline-offset: -2px;
}

.wsd-select-wrapper > select::-ms-expand {
    display: none;
}

.wsd-select-wrapper {
    position: relative;
}

.wsd-select-wrapper:before {
    content: '\f0d7';
    font-family: FontAwesome;
    color: #888;
    display: inline-block;
    font-size: 80%;
    position: absolute;
    right: 11.5px;
    pointer-events: none;
    border-left: 1px solid $color-gray;
    padding-left: 11.5px;
    line-height: 33px;
    user-select: none;
}

///// wsdSlider directive styling
/* The switch - the box around the slider */
.switch {
    position: relative;
    display: inline-block;
    width: 60px;
}

/* Hide default HTML checkbox */
.switch input {
    opacity: 0;
    width: 0;
    height: 0;
}

/* The slider */
.slider-wrapper {
    &.focus > * > .wsd-slider {
        outline: 5px auto $outline-color;
        outline-offset: -1px;
        box-shadow: 0px 0px 5px $outline-color;
    }
}

.wsd-slider {
    position: absolute;
    cursor: pointer;
    top: 0;
    left: 0;
    right: 0;
    bottom: 0;
    background-color: $wsd-slider-inactive-background;
    -webkit-transition: .4s;
    transition: .4s;
    border-radius: 4px;
    height: 27px;
    width: 50px;
    margin-top: 2px;
}

.wsd-slider:before {
    position: absolute;
    content: "";
    height: 23px;
    width: 23px;
    left: 2px;
    bottom: 2px;
    background-color: $wsd-slider-button-color;
    -webkit-transition: .2s;
    transition: .2s;
    border-radius: 4px;
}

/** Bottom selection bar **/
.selected-items-bar {
    position: fixed;
    height: 0;
    width: 100%;
    bottom: 0;
    left: 0;
    padding: 5px;
    z-index: 20;
    border-top: $gray-border;
    background-color: $background-primary;

    -webkit-box-shadow: 0px -3px 3px -2px rgba(148,148,148,1);
    -moz-box-shadow: 0px -3px 3px -2px rgba(148,148,148,1);
    box-shadow: 0px -3px 3px -2px rgba(148,148,148,1);

    -webkit-transition: all linear 0.2s;
    -moz-transition: all linear 0.2s;
    -o-transition: all linear 0.2s;
    -ms-transition: all linear 0.2s;
    transition: all linear 0.2s;

    .col-left {
        padding-top: 5px;
        padding-left: 20px;
    }

    .col-right {
        padding-right: 20px;
        text-align: center;
    }

    .btn-next {
        min-width: 80px;
    }

    .bottom-drawer {
        display: flex;
        align-items: center;
    }

    .selected-items-container {
        display: flex;
        flex-direction: column;
    }

    .selected-items-label {
        display: flex;
        flex-wrap: wrap;
    }

    .padding-right {
        padding-right: 16px;
    }

    .pills-container {
        width: 100%;
        padding-top: 10px;
      	max-height: 100vh;
      	overflow: auto;
    }

    .item-pill {
        padding-right: 8px;
        padding-top: 8px;
    }
}

.show-selected-items-bar {
    height: auto;
    padding: 10px;
    padding-bottom: 16px;
}

/** slider */
input:checked + .wsd-slider {
    background-color: $wsd-slider-active-background;
}

input:focus + .wsd-slider {
    box-shadow: 0 0 1px $input-border-focus-color;
}

input:checked + .wsd-slider:before {
    -webkit-transform: translateX(23px);
    -ms-transform: translateX(23px);
    transform: translateX(23px);
}

// wsd day selector
.wsd-day-selector {
    display: flex;
    text-transform: capitalize;
}

.wsd-day-selector__day {
    background: $background-primary;
    margin-right: 12px;
    height: 34px;
    width: 46px;
    text-align: center;
    line-height: 32px;
    border: $gray-border;
    border-radius: 4px;
    cursor: pointer;
    user-select: none;
    -ms-user-select: none; /* Internet Explorer/Edge */
    padding: 0 8px;

    &.selected:hover {
        background-color: $day-selector-selected-background-hover;
    }
}

.wsd-day-selector .selected {
    background: $day-selector-selected-background;
    color: $color-white;
}

//column padding when you need same padding as column but not using col
.col-pad {
    padding-left: 8px;
    padding-right: 7px;
}

.col-mar {
    margin-left: 8px;
    margin-right: 7px;
}

.row-margin {
    margin-left: -7px;
    margin-right: -8px
}

.alert a {
    color:inherit;
}

.map-view .mapContainer .zoomContainer {
    flex-direction: row;
}

@media (min-width: 768px) {
    .selected-items-bar {
        .col-left {
            padding-left: 27px;
        }
    }
}

@media (max-width: 991px) {
    .search-filter {
        .all-day-recurring{
            padding-top:0px;
            padding-bottom:0px;
        }
      
      .another-building:not(:last-of-type) {
        border-bottom:1px solid $color-gray;
        padding-bottom:16px;
      }

      .another-building {
        padding-top:15px;
        .building-delete-icon {
          position: absolute;
          top: -5px;
          right: 15px;

          .search-label {
            display:none;
          }
        }
      }

      .add-more-building {
        margin-top:0;
      }
    }
    .col-2-max-flex-width {
        max-width: none;
    }

    .search-filter .flex-row {
        flex-direction: column;
    }

    .col-pad {
        padding-bottom: 15px;
    }

    .reservable-filter-wrapper {
        margin-top: 0 !important;
    }
}

@media (min-width: 992px) {
    .col-2-max-flex-width {
        max-width: 250px;
    }

    .building-picker-width {
        max-width : 330px;
    }

    .floor-area-picker-width {
        max-width : 165px;
    }

    .schedule-view  {
        .reservable-details {
            div:not(:last-child) {
                margin-bottom: 0;
            }
        }
        .row--item {
            .schedule-col {
                height: 87px;
            }
          .availability-score{
            height: 110px;
          }
        }
    }
}

@media (min-width: 1200px) {
    .col-max-width {
        max-width : 368px;
    }
}

/** Gantt */
@media(max-width: 1199px) {
    .btn-label-reserve { display: none; }
    .btn-icon-reserve {
        display: initial;
        font-size: medium;
    }

    .row--item  {
        .btn-reserve {
            padding: 0;
            background:transparent;
        }


        .btn-add {
            width:100% !important;
            padding: initial !important;
            border-style: none !important;
            box-shadow: none !important;
        }

        .btn-remove {
            border-style: none !important;
            -webkit-box-shadow: none !important;
            -moz-box-shadow: none !important;
            box-shadow: none !important;
            background-color: unset !important;
        }
    }
}

@media (min-width: 1200px){
    .btn-label-reserve { display: initial; }
    .btn-icon-reserve { display: none; }

    .row--item  {
        .btn-reserve { padding: initial; }
    }
}


// CSS styling that will only be applied when Cabrillo is executing in ServiceNow's native mobile apps.
.wsd-mesp-wrapper {
    .mesp-p-r-8 {
        padding-right: 8px;
    }

    // Custom
    .search-filter {
        button {
            padding-top: 5px;
            padding-bottom: 5px;
        }

        .search-label {
            margin-bottom: 10px;
        }

		.ng-empty .select2-chosen {
			// color: $color-placeholder;
		}
	}

    .wsd-reservable-filter {
        .panel-body {
            padding-top: 10px;
            padding-bottom: 10px;
        }

        .filter-item-capacity {
            .list-group {
                padding: 15px;
            }
        }

        .filter-item {
            a {
                top: 10px;
            }
        }

        .list-group-item {
            padding-top: 15px;

            &:last-of-type {
                padding-bottom: 15px;
            }
        }
    }

    .reservable-card {
        border: 1px solid $filter-border-color;

        .item-content {
            padding: 15px;
        }

        .fa-check {
            position: relative;
            top: -2px;
        }

        .btn-reserve {
            margin-top: 20px;
            padding-right: 8px;
        }
    }

    // ServiceNow component | Bootstrap
    .select2-container {
        a {
            margin-left: 0;
        }

        .select2-arrow {
            right: 10px !important;
        }
    }
}



.info-container {
    height: auto;
    width: auto;
}

.nav-tabs {
    border : 0px;
    li {
        margin-bottom : 0px;
        a {
            color : $text-secondary;
            cursor : pointer;
            text-overflow : ellipsis;
            max-width : 200px;
            overflow : hidden;
            padding: 8px 15px;
        }
        a:hover{
            border-color: transparent;
            background-color: transparent;
        }
    }
    > li.active {
        > a {
            // Doing this as UX team wanted same color in both the portals (ESC and WS)
            color: $brand-primary;
            cursor : pointer;
            border-top: 0px;
            border-left: 0px;
            border-right: 0px;
            border-bottom : 2px solid $brand-primary;
        }
        a:hover{
            border-bottom-color: $brand-primary;
        }
    }
}


.types-menu {
    margin-left : 10px;
    margin-right : 10px;
    display : flex;
    padding-top : 16px;
}
.types-list {
    display: inline-flex;
    padding: 0;
    list-style: none;

}
.types-list > li  > a {
    white-space: nowrap;
}

.more-types-list {
    display :flex;
    flex-direction : column;
    z-index: 9000;
    position: absolute;
    right: 0;
    opacity: 0;
    visibility: hidden;
    transition: 0.5s;
    padding: 0;
    border-radius: 2px;
    background: $background-primary;
    text-align: center;
    box-shadow : 0px 2px 10px rgba(94, 94, 94, 0.2);
    list-style: none;
    margin-top : 5px;
    width : 200px;
    overflow : auto;
    max-height : 200px;
    border: 1px solid $color-light-gray;
}

.show-more-types {
    opacity: 1;
    visibility: visible;
}

.more-types-list li{
    padding : 5px;
    a {
        color : $text-secondary;
        padding : 0px;
    }
}
.more-types-list li:hover {
    background-color: $brand-primary-lightest;
    a {
        color : $color-black !important;
        white-space: none
    }
}

.more-types-list li.active a {
    color : $brand-primary;

}

.nav .open > a{
    border : 0px;
    background-color : $color-white;

}

.types-list > li:last-child {
    max-width : 200px;
}


.form-check-input {
    cursor: pointer;
    vertical-align : top;
}
.form-check-label {
    margin-left:10px;
    cursor: pointer;
}

.margin-top-24 {
    margin-top : 24px;
}

.padding-24 {
    padding : 24px;
}
.p-l-24{
    padding-left : 24px;
}
.p-r-24{
    padding-right : 24px;
}
.type-selected-from-more {
    margin-right : 5px;
    display : none;

}
.more-types-list li.active .type-selected-from-more{
    display : inline !important;
}

.reservation-paths {
    display:flex;
    margin-bottom: 16px;
    margin-top: 24px;
    padding-left: 24px;
    padding-right: 24px;
    div {
        margin-right : 20px;
    }
}
.more-title {
    display: inline-flex;
    min-width: 0;
    align-items: center;
    max-width: 80%;
}

.more-title div {
    text-overflow: ellipsis;
    overflow: hidden;
}

.dropdown-icon {
    display: inline-flex;
    align-items: center;
    overflow: auto;
}
.reservation-heading {
    font-weight: 600;
    font-size: 32px;
    line-height: 35px;
    margin: 0 0 6px;
}
.reservation-info-text {
    font-weight: 400;
    font-size: 16px;
    line-height: 23px;
    margin-bottom: 24px;
}
input[type="radio"] {
    -webkit-appearance: none;
    -moz-appearance: none;
    appearance: none;
    display: inline-block;
    width: 15px;
    height: 15px;
    padding: 3px;
    background-clip: content-box;
    border: $gray-border;
    border-radius: 50%;
    content: "";
    display: inline-block;
}
input[type="radio"]:checked {
    background-color: $brand-primary;
}
input[type="radio"]:focus {
    outline: 0px;
}

.reservation-paths label {
    margin-bottom : 0px;
}
.more-types-dropdown > li {
    padding : 0;
}

.more-dropdown-mask {
    position: fixed;
    left: 0;
    top: 0;
    min-height: 100vh;
    min-width: 100vw;
    height: auto;
    width: auto;
    opacity: 0;
    z-index: 1058;
    display: none;
}

.more-dropdown-mask-active {
    color: $text-secondary;
    display: block;
}

.no-resv-paths {
    margin : 20px 0px;
}
.timezone {
    font-size: $font-size-xs;
    padding-top: 2px;
    font-weight: 400;
    color : $text-secondary;
}

@media(max-width: 515px) {
    .reservation-paths {
        display : inline-block;
    }
    .nav-tabs >li > a {
        max-width : 150px;
    }
    .schedule-view .row--item .schedule-col.col-right {
        padding-left: 0px;
        padding-right: 0px;
    }
    .pills-container {
        display: none !important;
    }
  
  .pull-right {
    float:none !important;
  }
  
  .edit-search {
    display:block;
    margin-top:10px;
  }
  
  
  .search-filter {
    .another-building:not(:last-of-type){
      border-bottom:1px solid $color-gray;
      padding-bottom:16px;
    }

    .another-building {
      .building-delete-icon {
        display: block;
        float: none !important;
        text-align: right;

        .search-label {
          display:none;
        }
      }
    }
    .add-more-building {
      margin-top:0;
    }
  }
}

/* This is to handle a border issue esc portal */
.wsd-search > .row {
    background: transparent;
  	border-radius: $border-radius-large;
  	box-shadow: $sp-panel-box-shadow;
  	margin-bottom: $sp-space--xl;
  	padding: $sp-space--xl;
  	@media (max-width: 767px){
      padding: $sp-space--lg;
      margin-left: -$sp-space--sm;
      margin-right: -$sp-space--sm;
  	}
  	
  >h2{
    margin-top: 0;
  }
  
  wsd-search-filter{
    hr {
      display: block;
    }
    .tree-btn-container .form-group {
      margin-bottom: 0;
    }
  }
}

.indoor-map-container {
    position: relative;
    height: 65vh;
    overflow: hidden;
    display: flex;
    flex-direction: column;
}

.indoor-map-container {
    position: relative;
    flex: 1;
}

.floor-selector {
    position: absolute;
    bottom: 10px;
    right: 20px;
    z-index: 1;
    display: flex;
    flex-direction: column;
}

.floor-selected {
    background-color: green;
}

.header {
    background-color: white;
    position: absolute;
    top: 0;
    left: 0;
    right: 0;
    display: flex;
    align-items: baseline;

    .title {
        color: black;
        font-size: 20px;
    }

    .subtitle {
        color: gray;
        font-size: 15px;
        margin-left: 15px;
    }
}

.margin-bottom-20 {
    margin-bottom: 20px;
}

.margin-bottom-16 {
    margin-bottom: 16px;
}

.collapsed-search {
  padding: 24px;

  .collapsed-search-title {
    font-size: 18px;
  }

  .search-pill {
    font-size: 18px;
    font-weight: 400;
    margin-right:5px;
  }
  

  a {
    font-size:16px;
  }
}


.horizontal-card {
    height: 100%;

    .horizontal-card__header-container {
        height: 22px;
    }

    .horizontal-card__actions {
        margin-top: auto;
    }

    .horizontal-card__center-content {
        margin-bottom: 16px;
    }

}

.card-view-container {
    display: flex;
    flex-wrap: wrap;
}

.mapContainer #mapView #mappedinModal {
    width: 300px;
}

.horizontal-card__identifier {
    color: $text-color;
}

.horizontal-card__title {
    color: $text-color;
}

.horizontal-card__subtitle {
    color: $text-muted;

}

.horizontal-card__meta-row {
    color: $text-secondary;
}

.card-btn-secondary {
    border-color: $brand-primary;
    color: $brand-primary;
}

.btn-add-card {
}

.btn-remove-card {
    background-color: $background-light-gray;
}


//indoor map card css

.vertical-card__panel {
    height: 100%;
    display: flex;
    flex-direction: column;
    Justify-content: space-between;
    min-height : 250px;
}

.vertical-card {
    height : 100%;
    --card-light-border : none;
    border-radius : none;
}
.wsd-vertical-card-height {
    height : 100%;
}
.wsd-indoor-map-card {
    height : 100%;
}
#card-placeholder {
    width : 100%;
}

.map-overlay {
    position : absolute;
    top : 0;
    left : 0;
    width: 100%;
    height: 100%;
    z-index:15;
    background-color: rgba(255, 255, 255, 0.8);
}

.loading-text {
    text-align: center;
    font-size : 16px;
    position: relative;
    float: left;
    top: 50%;
    left: 50%;
    transform: translate(-50%, -50%);
    padding: 40px;
    border: 1px solid #DADDE2;
    border-radius: 4px;
    background-color: rgba(255, 255, 255);
}
.spinner-margin {
    margin-bottom : 16px;
}

.searching-loader {
  display: flex;
}

.loader-progress-bar {
  height: 16px;
  width:  164px;
  border-radius: 8px;
  background: linear-gradient(90deg, $color-light-gray, $color-very-light-gray);
}

.cards-overlay {
  display: flex;
  margin-top: 36px;
  margin-bottom: 16px;
  justify-content: center;
  width: 100%;
  height: 100%;
  z-index:15;
  background-color: rgba(255, 255, 255, 0.8);
}

.loading-text-cards{
  text-align: center;
  font-size : 16px;
  top: 50%;
  left: 50%;
  padding: 40px;
  border: 1px solid #DADDE2;
  border-radius: 4px;
  background-color: rgba(255, 255, 255);
}

.font-base{
    font-size: $font-size-base;
}

.p-l-0{
    padding-left:0px !important;
}

//indoor map zoom in and zoom out button color
.control-button{
    color: $brand-primary;
}
#icon-container i {
    color: $brand-primary;
}
#togglePattern input:checked + .slider {
    background-color: $brand-primary;
}
#togglePattern input:focus + .slider {
    box-shadow: 0 0 1px $brand-primary;
}

.indoor-map-nearby-user-marker {
    position:absolute;
    cursor:pointer;
    background: $color-white;
    width:50px;
    height:50px;
    margin-left:22px;
    border-radius:50% 50% 50% 0%;
    border: 1px solid lightgray;
}
.indoor-map-nearby-user-marker img{
    width:45px;
    height:45px;
    margin:1.5px;
    border-radius:50% 50% 50% 50%;
}
.indoor-map-nearby-user-initials_class {
    width:40px;
    height:40px;
    margin:5px;
    border-radius:50% 50% 50% 50%;
    text-align: center;
    line-height: 40px;
    font-size: 20px;
    background-color: $color-light-gray;
    font-weight: 600;
}

.booked-space-tag {
    color : #CC293C;
    background-color : #F8C8CD;
}
.available-space-tag {
    background-color: $label-success-bg;
  	color: $text-color;
  	font-weight: bold;
}

.more-building-section {
    background-color: $color-very-light-gray;

    .more-buildings {
        width: 100%;
        scroll-behavior: smooth;
        overflow-x: auto;
        white-space: nowrap;
    }

    .building-card {
        width: 295px;
        padding: 14px 16px 14px 16px;
        border-radius: 10px;
        margin: 15px;
        background-color: $color-white;
        display: inline-block;
        vertical-align: top;
    }

    .scroll-chevron {
	      height: 100%;
        z-index: 5;
    }

    .chevron-left {
        position: absolute;
        left: 0;
    }

    .chevron-right {
        position: absolute;
        right: 0;
    }

    .btn-round {
        border-radius: 50% !important;
        width: 30px;
        height: 30px;
        padding: 0;
        vertical-align: middle;
        top: 50%;
        left: 50%;
        transform: translate(-50%, -50%);
        position: absolute;
    }
}

.divider {
  border-top:1px solid $color-light-gray;
  margin-top:10px;
}
.seperator{
  margin-left:-24px;
  margin-right:-24px;
  width: -moz-available;          /* WebKit-based browsers will ignore this. */
  width: -webkit-fill-available;  /* Mozilla-based browsers will ignore this. */
  width: fill-available;
}

.building-strip > .row {
  overflow-x: hidden;
  white-space: nowrap;
  scroll-behavior: smooth;
}
.building-strip > .row > .col-md-2 {
  display: inline-block;
  float: none;
  margin-right: 12px;
  margin-bottom: 6px;
}

.current-search-building {
  background: $brand-primary-lightest;
  //border: 1px solid $brand-primary;
}


.building-strip {
  .scroll-chevron {       
    z-index: 1;
    height: 100%;
    padding: 30px 0;
  }
  .scroll-btn-secondary{
    border-color: $brand-primary;
    color: $brand-primary;
  }
  .chevron-left {
    background: linear-gradient(to left, rgba(0,0,0,0) , $background-primary);
    position: absolute;
    left: 0;
  }
  .chevron-right {
    background: linear-gradient(to right, rgba(0,0,0,0) , $background-primary);
    position: absolute;
    right: 0;
  }
  .btn-round {
    border-radius: 50%;
    width: 30px;
    height: 30px;
  }
  
  .btn-scroll-right {
    padding: 1px 0 0 3px;
  }
  
  .btn-scroll-left {
   padding: 1px 3px 0 0px;
  }

  
  .building-card {
    min-width:150px;
    max-width:200px;
    height:86px;
    border-radius:10px;
    padding:10px 16px;
    margin-right: 12px;
    display:inline-block;
    margin-right:12px;
  }
  
  .building-card:focus {
    outline: none;
    border: 1px solid $brand-primary;
    box-shadow:none;
  }
  
  .building-card:hover {
    box-shadow: 0 0 5px rgba(0,0,0,0.1);
  }
  
  .building-card div {
    font-size: 12px;
  }
  
  .mb-6 {
    margin-bottom: 6px;
  }
}

.selected-pill{
  display: inline-block;
  vertical-align:middle;
  border: 1px solid #E6E8EA;
  max-width: 190px;
  margin-right: 10px;
  margin-top: 10px;
  padding: 8px 12px;
  border-radius: 10px;
  
  .pill-details{
    display: inline-block;
    overflow: hidden;
    margin-right:10px;
  }
	
  .ellipsis-text{
    text-overflow: ellipsis;
    white-space: nowrap;
    overflow: hidden;
    max-width:140px;
  }
  
  .pill-header {
    font-style: normal;
    font-weight: 600;
    font-size: 14px;
    line-height: 15px;
    margin: 5px 0px;
  }
  
  .pill-content{
    font-style: normal;
    font-weight: 600;
    color : $text-secondary;
    font-size: 10px;
    line-height: 14px;
    margin: 10px 0px 0px 0px;
  }
}

.reservable-count-section {
  font-style: normal;
  font-weight: 600;
  font-size: 14px;
  line-height: 15px;
  display:inline-block;
  vertical-align:middle;
  margin-top:10px;

  .reservable-count{
    margin-top: 0px;
    margin-bottom: 6px;
  }
}

.padding-right-27 {
  padding-right:27px
}

.padding-left-27 {
  padding-left:27px
}

.flex-row-wrap {
  flex-flow: row wrap;
}

.horizontal-card__identifiers {
  .alert-info {
    background-color: $label-info-bg;
    border-color: $label-info-bg;
    font-weight: bold;
  }
}

#container{
  [type="checkbox"]:checked + label:before {
      background: $brand-primary;
  }
  
  .nav-tabs{
    border-bottom: 0.1rem solid transparent; !important;
  }
 
  .nav-tabs  > li.active a{
      border-color: $brand-primary !important;
      color: $brand-primary !important;
      background: none;
  }
  .nav-tabs > li > a {
      color: #181A1F;
      border-bottom-width: .2rem !important;
  }
  
  .nav-tabs > li > a:hover {
      color: $brand-primary !important;
  }
}

Server Script:

(function() {  /* populate the 'data' object */  /* e.g., data.table = $sp.getValue('table'); */
	data.isFavoritesEnabled = ($sp.getValue('enable_favorites') === 'true') && gs.tableExists('sn_ex_sp_favorite_content_config');
	data.sessionUserId = gs.getUserID();
	data.enable_recurring_score = gs.getProperty('sn_wsd_rsv.enable_recurring_score') == 'true'? true:false;
	if(input && (input.action === 'getFavoriteWidgets')){
		_createFavoriteWidgetsForReservables();
		return;
	}

	if(input && (input.action === 'getAvailabilityScoreOfSelectedLocation')){
		data.availabilityScore = new WSDRecurringReservationService().getReservableItemsAvailabilityScoreForRecurringPattern(input.reservableType, input.spaces, input.recurringPattern, input.reservableQuantityMap, input.enable_allocation_duration_check);
		return;
	}

	var reservableModuleService = new WSDReservableModuleService();

	if(input && (input.action === 'getRsvModuleTreeData')){
		var rsvModuleBuildingsData = reservableModuleService.getRsvModuleBuildingsTreeData(input.reservableModuleSysId, input.neighborhoodId);
		data.rsvModuleTreeData = rsvModuleBuildingsData ? rsvModuleBuildingsData.rsvModuleTreeData : [{}];
		data.nbhBuildingsTreeData = rsvModuleBuildingsData ? rsvModuleBuildingsData.nbhBuildingsTreeData : [{}];
		return;
	}
	
	if(input && (input.action === 'getNeighborhoodBuildings')){
		if(input.neighborhoodId && GlidePluginManager.isActive('com.sn_wsd_space_mgmt')){
			data.neighborhoodBuildings = new WSDReservableModuleService().getNbhBuildingsForRsvModule(input.neighborhoodId, input.rsvModuleBuildingSysIds, true);
			data.userNeighborhoodAssignmentBuildingAndFloor = new WSDSearchService().getBuildingAndFloorFromNeighborhoodUserAssignment(input.neighborhoodId);
		}
		return;
	}

	var MODE_TYPE = {
		search: 'search',
		edit: 'edit'
	};
	var BUILDING_TABLE = sn_wsd_core.WPConstants.TABLES.BUILDING;
	var DEFAULT_DAY_START = '09:00';
	var DEFAULT_DAY_END = '17:00';
	var FLOOR_TABLE = 'sn_wsd_core_floor';
	var searchService = new WSDSearchService();
	var userUtils = new WSDUserUtils();
	var wsdCoreUtils = new sn_wsd_core.WPCoreUtils();
	
	data.showReservationDetails = gs.getProperty('sn_wsd_core.floor_plan.portal.show_reservation_details') === 'true';
	data.applicableMappingTech  = wsdCoreUtils.getMappingTechnology();
	data.isMesp = $sp.getValue('url_suffix') == 'mesp';
	
	data.showDisplayUsersToggleButton = gs.getProperty("sn_wsd_space_map.display_seat_assignment") === 'true';
	
	if(data.applicableMappingTech == sn_wsd_core.WPConstants.WSD_SOURCE.INDOOR_MAPS) {
		data.mapCampusExternalIdToBuildings = getIndoorMapCampusIdArr();
		data.indoorMapCampusIds = Object.keys(data.mapCampusExternalIdToBuildings);
		data.mapOptions = { 
			config: {
				viewTypeId: sn_wsd_indoor_map.WSDIMUtils.getWSDIndoorMapViewTypeProperty(),
				//campusIds: data.indoorMapCampusIds
			}
		};
	}

	function getIndoorMapCampusIdArr(){
		var mapCampusExternalIdToBuildings = {};
		var buildingGr = new GlideRecord(BUILDING_TABLE);
		buildingGr.addActiveQuery();
		buildingGr.addQuery('wsd_source',sn_wsd_core.WPConstants.WSD_SOURCE.INDOOR_MAPS);
		buildingGr.addNotNullQuery('external_id');
		buildingGr.addQuery('is_reservable',true);
		buildingGr.orderBy('order');
		buildingGr.orderBy('name');
		buildingGr.query();
		while(buildingGr.next()){
			//Prevent empty campus external_id
			if(!buildingGr.campus || !buildingGr.campus.external_id)
				continue;
			
			if(!mapCampusExternalIdToBuildings.hasOwnProperty(buildingGr.campus.external_id))
				mapCampusExternalIdToBuildings[buildingGr.campus.external_id] = [];
			mapCampusExternalIdToBuildings[buildingGr.campus.external_id].push({
				sys_id : buildingGr.getUniqueValue(),
				externalId : buildingGr.getValue('external_id'),
				displayValue : buildingGr.getDisplayValue()
			}); 
		}
		return mapCampusExternalIdToBuildings;
	}
	
	initialize();

	/**
	 * Initializes the widget server side.
	 * Gets initial batch of reservations and stores in in data object.
	 */
	function initialize(){
		data.mode = $sp.getParameter('mode');
		data.reservable_module = $sp.getParameter('reservable_module');
		data.reservation_id = $sp.getParameter('reservation_id');
		data.reservation = _loadReservation(data.mode, data.reservation_id);
	
		var reservableModuleInfo = new WSDReservableModuleService().getReservableModule(data.reservable_module);
		if( reservableModuleInfo && reservableModuleInfo.reservable_table){
			data.buildingId = _getBuildingId($sp.getParameter('reference_location_id'), reservableModuleInfo);
		}
		
		//use the reservable module, building id, shift id if passed from url params. Override the previous search values with url params
		data.initSearchConfig = searchService.getInitSearchConfig(data.reservable_module, data.buildingId, $sp.getParameter('shift'), true, WSDConstants.SOURCE_WIDGET.advRsv);
		//use the start and end time, if passed from url params
		data.initSearchConfig.start = $sp.getParameter('start');
		data.initSearchConfig.end = $sp.getParameter('end');
		
		// check if user preference for indoor map pattern usage exists and create it otherwise
		if (gs.nil(gs.getUser().getPreference('wsd_indoor_mapping_pattern'))) {
			gs.getUser().savePreference('wsd_indoor_mapping_pattern', false);
		}
		data.patternEnabled = gs.getUser().getPreference('wsd_indoor_mapping_pattern') === "true";
		
		/* if nearByUserId available in url params and browse near a person enabled for the user module, 
		need to set the browse path to Browse near a person and pass the nearby user reservation details 
		obtained from the url 
		*/
		var nearbyUserId = $sp.getParameter('near_by_user_id');
		if(nearbyUserId && data.initSearchConfig.reservable_module && data.initSearchConfig.reservable_module.browse_near_a_person_enabled){
			data.initSearchConfig.nearbyUserMode = true;
			data.initSearchConfig.nearbyUserDetails = userUtils.getUserDetails(nearbyUserId);
			data.initSearchConfig.nearbyUserLoc = $sp.getParameter('reference_location_id');
		}
		var reservableModuleEQ = 'available_inLIKEadvanced_reservation';
		data.reservable_modules = reservableModuleService.getActiveReservableModules(reservableModuleEQ);
		data.translations = _getTranslations();

		var displayFiltersDefaultProperty = gs.getProperty(WSDConstants.SYSTEM_PROPERTY.displayFiltersDefault.name, WSDConstants.SYSTEM_PROPERTY.displayFiltersDefault.defaultValue);
		if (displayFiltersDefaultProperty === WSDConstants.SYSTEM_PROPERTY.displayFiltersDefault.choices.userPreference) {
			data.initialShowReservableFilterValue = WSDUtils.safeBool(gs.getUser().getPreference(WSDConstants.USER_PREFERENCE.expandCollapseFilterState));
		} else
			data.initialShowReservableFilterValue = displayFiltersDefaultProperty === WSDConstants.SYSTEM_PROPERTY.displayFiltersDefault.choices.expanded;
		

		options.page_size = _getDefaultPageSize();
		_fetchConfiguredStartEndDay();
	}

	function _createFavoriteWidgetsForReservables() {
		data.favoriteWidgets = {};	
		if(input.reservablesFavData && input.reservablesFavData.length > 0 && data.isFavoritesEnabled) {
			var favData = input.reservablesFavData;
			for(var i=0; i<favData.length; i++) {
				var favoriteData = favData[i];
				if(favoriteData) {
					var id = favoriteData.sysId;
					var options = {
						"table": favoriteData.tableName,
						"sys_id": id,
						"isFavorite": favoriteData.isFavorite,
						"overrideFavoriteEvaluation": true,
						"broadcastFavoriteRecord": true
					};
					var favoriteWidget = $sp.getWidget('ec_favorite', options);	
					data.favoriteWidgets[id] = favoriteWidget;
				}
			}
		}
	}

	/**
	 * fetch day start and day end from sys property, use default value if not present
	 */
	function _fetchConfiguredStartEndDay() {
		data.dayStart = gs.getProperty(WSDConstants.SYSTEM_PROPERTY.dayStart, DEFAULT_DAY_START);
		data.dayEnd = gs.getProperty(WSDConstants.SYSTEM_PROPERTY.dayEnd, DEFAULT_DAY_END);
	}

	/**
	 * load reservation
	 * @param {string} mode - edit or new
	 * @param {string} reservationSysId - id of reservation in case it's an edit
	 * @return {Reservation} editing reservation object
	 */
	function _loadReservation(mode, reservationSysId) {
		if (mode !== MODE_TYPE.edit)
			return null;

		var reservationService = new WSDReservationService();
		var reservationResult = reservationService.getReservationById(reservationSysId, false);
		if (reservationResult.success && reservationResult.reservationAcl.read && reservationResult.reservation.edit_restriction.value === WSDConstants.ROOM_RESERVATION_EDIT_RESTRICTION.noRestriction)
			return reservationResult.reservation;

		WSDLogger.error('WSD Search Widget.getReservationById', 'Reservation is invalid for editing mode', reservationSysId);
		return null;
	}
	
	function _getBuildingId(locationId, reservableModuleInfo){
		var spaceGr = new GlideRecord(reservableModuleInfo.reservable_table);
		if(spaceGr.get(locationId))
			return spaceGr.getValue('building');
		else 
			return null;
	}

	/**
	 * Get the default page size from either widget options, system property or fall-back value
	 * @returns {number}
	 * @private
	 */
	function _getDefaultPageSize() {
		if (!isNaN(options.page_size) && options.page_size > 0)
			return options.page_size;

		return WSDUtils.getDefaultPageSize();
	}

	/**
	 * Builds the translations obj for client
	 * @returns {object}
	 */
	function _getTranslations() {
		return {
			reservableReserveLabel: gs.getMessage('Reserve {0}'),
			reservableSelectLabel: gs.getMessage('Select {0}'),
			reservableDeselectLabel: gs.getMessage('Remove {0}'),
			reservableCapacityLabel: gs.getMessage('Max space capacity is {0}'),
			reservablePurposeLabel: gs.getMessage('Can be used for {0}'),
			reservableStandardServicesLabel: gs.getMessage('Standard available services are: {0}'),
			reservableAvailabilityLabel: gs.getMessage('{0} is available between {1}'),
			noReservationsFoundNotification: gs.getMessage('No reservation dates for {0} were found.'),
			browseNearAPersonDateConflict: gs.getMessage("The selected date will not overlap with {0}'s reservation"),
			allDayAnnotation : gs.getMessage("All-day reservations start at {0} and end at {1}"),
			enforcedAllDayPersistentBanner : gs.getMessage("You must reserve for the entire day from {0} to {1}."),
			updateReservationTitle: gs.getMessage("Update {0} reservation"),
			editOccurrenceTitle: gs.getMessage("Edit an occurrence of {0} reservation in a series"),
			nearbyUserSearchResultNotification: gs.getMessage("Showing the available results closest to {0}'s {1} reservation"),
			maxAllowedDaysInFutureMessage: gs.getMessage("You can only reserve this space up to {0} days in advance and for upto {1} total"),
			itemAddedToBasket: gs.getMessage("Item {0} has been added to the basket in the bottom panel of the page"),
			itemRemovedFromBasket: gs.getMessage("Item {0} has been removed from the basket in the bottom panel of the page"),
			maxAllowedDaysInFutureNullMessage : gs.getMessage("You can only reserve this space upto {0} total"),
			disableAllDayAnnotation : gs.getMessage("In multi-day reservation, 'all day' checkbox will remain disabled"),
			multiDayDatesValidationMessage: gs.getMessage("You cannot select more than {0} days if you are making a multi-day reservation. Please try again."),
			availabilityScoreMessage: gs.getMessage("dates available")
		};
	}
})();

Client Controller:

function wsdSearch($scope, $http, $window, $location, $timeout, $templateCache, $uibModal, cabrillo, spUtil, wsdStateService, wsdReservableSearch, wsdReservableMappingService, wsdMappedinService, wsdReservationBasket, wsdUtils, wsdReservationUtils, $sce, snAnalytics) {
    // custom type definitions can be found at the bottom of the file.

    var c = this;
    var indoorMapObj;
    var wsdIndoorMapService;
    moment.locale(g_lang);

    // Used to determine if Cabrillo is executing in ServiceNow's native mobile apps.
    c.isNative = cabrillo.isNative();

    c.previousView = {};
    c.MAP_TYPE = {
        MAPPEDIN: 'mappedin',
        INDOOR_MAPS: 'indoor_maps',
        NONE: 'none'
    }
    var DEFAULT_RESERVATION_PAGE_ID = 'wsd_reservation';
    var DEFAULT_DEBOUNCE_TIME = 350; // milisecond
    var BROWSE_ALL = "browse_all";
    var BROWSE_NEAR_A_PERSON = "browse_near_a_person";
    var BROWSE_BY_AREA = "browse_by_area";
    var BROWSE_BY_NEIGHBORHOOD = "browse_by_neighborhood";
    var MOBILE_VIEW = 'card'; //in mesp, only card view is available

    //send usernames to angular provider 
    c.displayUserNamesOnMap = {
        permanentAssignedUsers: c.data.showDisplayUsersToggleButton,
        reservedUsers: c.data.showReservationDetails
    };
    c.placeStyles = {};
    var reservationData = [];

    c.mapViewTabDesc = "${This is a map view that highlights available spaces. To hear a list of available spaces and pick one, switch to card view or schedule view.}";
    c.mapType = c.data.applicableMappingTech;
    c.data.reservable_modules = _.sortBy(c.data.reservable_modules, 'order', 'title');
    c.isRegularSearch = false;
    c.isFromShowMore = false;
    c.filterCount = 0;
    c.activeView = {};
    c.viewOptions = null;
    c.reservationId = null;
    c.reservableMapper = null;
    c.hasMore = false;
    c.isEditing = false;
    c.prBuildingTz = "";
    c.secBuildingTz = "";
    c.mappedReservables = []; // the view model of the original reservables
    c.selectedItems = []; // the list of user selected items
    c.searching = false;
    c.wasSearched = false;
    c.searchWasAuto = false;
    c.showReservableFilter = false;
    c.watcher = {};
    c.isOccurrence = false;
    c.isException = false;
    c.canSubmitReservation = true;
    c.missingSpaceMap = false;
    c.wsdMappedinReservationData = null;
    c.mappedinConfig = {};
    c.showMap = false;
    c.isRecurring = false;
    c.floorReservables = [];
    c.onMapSpaceSelect = onMapSpaceSelect;
    c.onMapEvent = onMapEvent;
    c.mountWsdMappedinComponent = mountWsdMappedinComponent;
    c.reservablesFavWidgets = {};
    c.wsdMappedinTemplates = {
        popupcard: $templateCache.get('map-rsv-popup.html'),
        tooltip: $templateCache.get('map-default-rsv-tooltip')
    };
    c.resultMsg = {
        title: '',
        msg: ''
    };

    c.selectedBuildingToSearch = {};
    c.searchBuildingList = [];
    c.searchFromBuildingStrip = searchFromBuildingStrip;
    c.canShowScrollForBuildingStrip = canShowScrollForBuildingStrip;
    c.scrollBuildingStrip = scrollBuildingStrip;
    c.showBuildingStrip = showBuildingStrip;

    var lastMapFilters = {};

    // notification
    c.notificationConfig = {};
    c.showNotification = false;

    c.hasError = false;
    c.editInfo = null;
    c.validRSVData = true;

    // bind methods:
    c.undoChangesAndBackToReservation = undoChangesAndBackToReservation;
    c.reserveReservable = reserveReservable;
    c.reserveReservables = reserveReservables;
    c.toggleReservableSelection = toggleReservableSelection;
    c.removeSelectedItem = removeSelectedItem;
    c.unSelectAll = unSelectAll;
    c.toggleViewOption = toggleViewOption;
    c.toggleReservableFilter = toggleReservableFilter;
    c.isChangeLocationDisabled = isChangeLocationDisabled;
    c.scheduleViewTotalStep = 5;
    c.isMultiItemSelection = false;
    c.isAnyItemSelected = false;
    c.loadMore = loadMore;
    c.onSortByChange = onSortByChange;
    c.$onInit = init;
    $scope.$on('$destroy', destroy);
    c.previouslySelected = {};
    c.initialLoadFoReselectCheck = false;
    c.cardActionsCallback = cardActionsCallback;
    c.checkKey = checkKey;

    c.legendTypeIndex = {
        available: 0,
        reserved: 1
    };

    // Indoor mapping variables
    c.wsdIndoorMapObject = {
        selectedFloor: {},
        isMapwizeLoading: false,
        isInitialIndoorMapLoad: false,
        neighborhoodSpaces: {}
    };
    c.onCardClose = onCardClose;
    c.wsdIndoorMapAvailabilityData = {};
    c.indoorMapSelectorsCache = {};
    c.onIndoorMapLoad = onIndoorMapLoad;
    c.floorSelectorOptions = undefined;
    c.buildingSelectorOptions = undefined;
    c.onBuildingSelectorChange = onBuildingSelectorChange;
    c.indoorMapCardTemplate = $templateCache.get("rsv-vertical-map-card.html");
    c.showAllSelectedReservables = false;
    c.cardActions = {
        add: {
            displayValue: '${Add}',
            value: 'add',
            classesToAdd: 'btn-add-card',
            type: 'secondary',
            isDisabled: false,
            label: '${Add}'
        },
        remove: {
            displayValue: '${Remove}',
            value: 'remove',
            classesToAdd: 'btn-remove-card',
            type: 'secondary',
            isDisabled: false,
            label: '${Remove}'
        }
    };
    c.patternEnabled = c.data.patternEnabled;
    c.onPatternEnabledChange = onPatternEnabledChange;

    $scope.$on("favoriteRecord", function($evt, favoriteRecord) {
        var updatedReservableData = wsdStateService.getState('updatedReservableData');
        if (!updatedReservableData)
            updatedReservableData = {};

        var updatedReservables = updatedReservableData.updatedReservables ? updatedReservableData.updatedReservables : {};
        var updatedFavoritesCount = updatedReservableData.updatedFavoritesCount ? updatedReservableData.updatedFavoritesCount : 0;

        if (c.sortBy == 'favorites_first') {
            if (updatedReservables[favoriteRecord.recordId]) {
                delete updatedReservables[favoriteRecord.recordId];
                if (!favoriteRecord.addToFavorite)
                    updatedFavoritesCount -= 1;
            } else {
                updatedReservables[favoriteRecord.recordId] = true;
                if (favoriteRecord.addToFavorite)
                    updatedFavoritesCount += 1;
            }
        }

        wsdStateService.setState('updatedReservableData', {
            updatedReservables: updatedReservables,
            updatedFavoritesCount: updatedFavoritesCount
        });
    });

    /** initialization function */
    function init() {
        wsdReservableMappingService.setTranslations(c.data.translations);
        wsdStateService.setState('isMesp', c.data.isMesp);

        _setIndoorMapConfig();
        _injectIndoorMapDependencies();
        _createModuleWatcher();
        _createReservableWatcher();
        _createSearchingStateWatcher();
        _createResultsFitSearchWatcher();
        _createFilterCountWatcher();
        _createReservableFilterWatcher();
        _createReservationBasketWatcher();
        _createIsRecurringWatcher();
        _createShiftTimeSpanWatcher();
        _createWindowResizeEventListener();
        _createReservationPathWatcher();
        _createSearchBuildingListWatcher();
        _createOverlappingRsvWatcher();
        _watchBackdropClick();
        try {
            c.reservationId = $location.search().reservationId;
            c.options.page_size = parseInt(c.options.page_size);
            c.reservable_module = c.data.reservable_module;
            c.showReservableFilter = c.data.initialShowReservableFilterValue;

            if (c.data.initSearchConfig && c.data.initSearchConfig.reservable_module) {
                c.viewOptions = c.data.initSearchConfig.reservable_module.reservable_views;
                if (!c.data.isMesp)
                    toggleViewOption(wsdUtils.getDefaultReservableView(c.viewOptions), true);
                else
                    toggleViewOption(wsdUtils.getMobileReservableView(c.viewOptions, MOBILE_VIEW), true);
            }

            _prepareSortBy();
            _prepareSearchMode();
        } catch (ex) {
            var errorMsg = '${An error has occurred while starting up. Please try again}';
            _showNotification(true, errorMsg, 'alert-danger', 'fa-exclamation-triangle');
        }
    }

    /**
     * Set initial configuration for indoor map.
     */
    function _setIndoorMapConfig() {
        if (c.mapType == 'indoor_maps') {
            if (c.data.initSearchConfig.floors && c.data.initSearchConfig.building && c.data.initSearchConfig.building.externalId) {
                c.wsdIndoorMapObject.selectedFloor.sys_id = c.data.initSearchConfig.floors.length > 0 ? c.data.initSearchConfig.floors[0].sys_id : null;
                c.data.mapOptions.config.centerOnBuildingId = c.data.initSearchConfig.building.externalId;
            } else if (c.data.initSearchConfig.building && c.data.initSearchConfig.building.campusExternalId) {
                c.data.mapOptions.config.centerOnCampusId = c.data.initSearchConfig.building.campusExternalId;
            }
            c.indoorMapConfig = c.data.mapOptions;
            c.wsdIndoorMapObject.isMapwizeLoading = true;
            c.wsdIndoorMapObject.isInitialIndoorMapLoad = true;
        }
    }

    /**
     * OnIndoorMapLoad 
     * @param {object} - indoor map object.
     */

    function onIndoorMapLoad(mapObj) {
        indoorMapObj = mapObj;
        indoorMapObj._iconsManager.addImages({
            'booked-room': 'red_dot.svg',
            'available-room': 'green_dot.svg',
            'selected-room': 'green_checkmark.svg'
        });

        setInitialFocusForIndoorMap();
        c.wsdIndoorMapObject.isInitialIndoorMapLoad = false;
        c.wsdIndoorMapObject.isMapwizeLoading = false;
        $timeout(function() {
            mapObj.resize();
        })
    };
    /**
     * inject wsdIndoorMapService wsd-indoor-mapping is installed.
     */
    function _injectIndoorMapDependencies() {
        if (c.mapType === c.MAP_TYPE.INDOOR_MAPS) {
            var injector = angular.element(document.body).injector();
            wsdIndoorMapService = injector.get('wsdIndoorMapService');
        }
    }

    /**
     * prepare search mode (new search or editing existing reservation), and set data accordingly
     * @private
     */
    function _prepareSearchMode() {
        c.mode = c.data.mode;
        c.isEditing = c.mode === 'edit';
        if (c.isEditing && (!c.data.reservation || !c.data.reservation.reservable_module || !c.data.reservation.reservable_module.sys_id)) {
            c.validRSVData = false;
            var msg = c.data.reservation ? '${Something went wrong with loading the reservable data}' : '${Invalid reservation to edit. The selected reservation is invalid or no-longer exists}';
            c.notificationConfig = {
                msg: msg,
                type: 'alert-danger',
                icon: 'fa-exclamation-triangle'
            };
            c.showNotification = true;
            return;
        }
        c.title = c.isEditing ? wsdUtils.formatString(c.data.translations.updateReservationTitle, c.data.reservation.reservable_module.inline_title) : '${Make a reservation}';
        c.subTitle = c.isEditing ? '${Change date, time, or location}' : "${Book available spaces and items, and they'll be ready when you need them}";
        if (c.isEditing) {
            // EDITING MODE
            c.reservation = wsdReservationUtils.resolveReservationForEdit(c.data.reservation);;

            // check if reservation is valid for editing
            if (!_isReservationValidForEdit())
                return;

            if (c.reservation.reservation_subtype){
                c.isOccurrence = c.reservation.reservation_subtype.value === 'occurrence';
                c.isException = c.reservation.reservation_subtype.value === 'exception';
						}

            if (c.isOccurrence)
                c.title = wsdUtils.formatString(c.data.translations.editOccurrenceTitle, c.data.reservation.reservable_module.inline_title);

            // fetch mapper based on the know reservable module
            c.reservableMapper = wsdReservableMappingService.createReservableMapper(c.reservation.reservable_module);
            c.wasSearched = true;

            var reservables = _getReservablesFromReservation(c.reservation);

            var buildingCount = 0;
            // Building a map of building:reserved spaces
            var locBuildingMap = {};
            if (c.reservation.building) {
                var buildingId = c.reservation.building.sys_id;
                locBuildingMap[buildingId] = [];
                buildingCount += 1;
            }

            for (var i = 0; i < reservables.length; i++) {
                var buildingId = reservables[i].building.sys_id;
                if (!locBuildingMap[buildingId]) {
                    locBuildingMap[buildingId] = [];
                    buildingCount += 1;
                }
                locBuildingMap[buildingId].push(reservables[i]);
            }
            c.reservation.locBuildingMap = locBuildingMap;
            c.reservation.isMultiBuildingRsv = buildingCount > 1;

            // on first load, all reserved items are also selected
            var reservationSelectedIds = reservables.map(function(item) {
                return item.sys_id
            });
            wsdReservationBasket.prime(reservationSelectedIds);
            c.previouslySelected = reservationSelectedIds.reduce(function(total, current) {
                total[current] = true;
                return total;
            }, {})

            _resolveReservablesResult(reservables, true);
        } else {
            if (c.reservable_module && (_.isEmpty(c.data.initSearchConfig) || _.isNull(c.data.initSearchConfig.reservable_module))) {
                var msg = '${The preselected type is unavailable. Please select a different type to make a reservation}';
                _showNotification(true, msg, 'alert-danger', 'fa-exclamation-triangle');
            }

            wsdReservationBasket.prime([]);
        }
    }

    /**
     * Check if the reservation is valid for editing
     * @return {boolean}
     * @private
     */
    function _isReservationValidForEdit() {
        var errorMsg;
        var errorMsgBuilding = '${Invalid reservation to edit. The selected building is invalid or no-longer exists}'
        var notificationType = 'alert-danger';
        var notificationIcon = 'fa-exclamation-triangle';

        if (!c.reservation || !c.reservation.sys_id) {
            errorMsg = '${Invalid reservation to edit. The selected reservation is invalid or no-longer exists}';
            _showNotification(true, errorMsg, notificationType, notificationIcon);
            return false;
        }

        if (!c.reservation.reservable_module) {
            errorMsg = '${Invalid reservation to edit. The selected module is invalid, no-longer exists or not active on this day}';
            _showNotification(true, errorMsg, notificationType, notificationIcon);
            return false;
        }

        if (c.reservation.location && c.reservation.location.building && !c.reservation.location.building.active) {
            _showNotification(true, errorMsgBuilding, notificationType, notificationIcon);
            return false;
        }

        var locations = c.reservation.locations;
        if (wsdUtils.arrayHasElement(locations) && locations[0] && locations[0].building && !locations[0].building.active) {
            _showNotification(true, errorMsgBuilding, notificationType, notificationIcon);
            return false;
        }

        return true;
    }

    /**
     * extract reservables from reservation (for edit mode).
     * @param {Reservation} reservation
     * @return {Reservable[]} fetched reservables from editing reservation. Result: location if it's a single, and locations if it's a multi-child reservation
     */
    function _getReservablesFromReservation(reservation) {
        var reservables = [];
        if (reservation.reservable_module.reservable_type === 'location') {
            if (_isMultiChildReservation(reservation)) {
                reservation.locations.forEach(function(loc) {
                    loc.is_reserved = true;
                    loc.is_selected = true;
                });

                reservables = reservation.locations;
            } else {
                reservation.location.is_reserved = true;
                reservables.push(reservation.location);
            }
        }

        return reservables;
    }

    /**
     * checkf if the editing reservation is multi child reservation
     * @return {boolean}
     * @private
     */
    function _isMultiChildReservation(reservation) {
        return wsdUtils.arrayHasElement(reservation.locations);
    }

    /**
     * Initialize the sortBy
     */
    function _prepareSortBy() {
        c.sortByOptions = {};
        c.sortByOptions[BROWSE_ALL] = [{
            id: 'a_z',
            text: !c.isNative ? '${Alphabetically}' : '${Alphabetically A-Z}',
            icon: 'fa-sort-alpha-asc',
            hint: '${Alphabetically a to z}'
        }, {
            id: 'z_a',
            text: !c.isNative ? '${Alphabetically}' : '${Alphabetically Z-A}',
            icon: 'fa-sort-alpha-desc',
            hint: '${Alphabetically z to a}'
        }];

        c.sortByOptions[BROWSE_NEAR_A_PERSON] = [{
            id: 'proximity',
            text: '${Proximity}',
            hint: '${Proximity}'
        }]

        c.renderSortBy = true;
        if (c.data.initSearchConfig.sort_by === 'favorites_first' && !c.data.isFavoritesEnabled)
            c.sortBy = c.sortByOptions[BROWSE_ALL][0].id;
        else
            c.sortBy = c.data.initSearchConfig.sort_by;

        // Push it only when favorites are present (favorites table exists and enabled favorites)
        if (c.data.isFavoritesEnabled) {
            c.sortByOptions[BROWSE_ALL].push({
                id: 'favorites_first',
                text: !c.isNative ? '${My favorites first}' : '${My favorites first}',
                icon: 'fa-sort-alpha-asc',
                hint: '${My favorites first}'
            });

            c.sortByOptions[BROWSE_NEAR_A_PERSON].push({
                id: 'favorites_first',
                text: !c.isNative ? '${My favorites first}' : '${My favorites first}',
                icon: 'fa-sort-alpha-asc',
                hint: '${My favorites first}'
            });

            // Set favorites_first as default sort order if there's no sortBy set by initSearchConfig
            if (!c.sortBy)
                c.sortBy = 'favorites_first'
        }

        if (!c.sortBy)
            c.sortBy = c.sortByOptions[BROWSE_ALL][0].id;

        var pathSortByObj = {};
        pathSortByObj[BROWSE_ALL] = c.sortBy;
        pathSortByObj[BROWSE_NEAR_A_PERSON] = "proximity";
        pathSortByObj[BROWSE_BY_AREA] = c.sortBy;
        pathSortByObj[BROWSE_BY_NEIGHBORHOOD] = c.sortBy;

        wsdStateService.setState('searchSortBy', pathSortByObj);

        c.sortBySelect2Options = {
            data: c.sortByOptions[BROWSE_ALL],
            minimumResultsForSearch: 0,
            formatResult: buildSortByItemTemplate,
            formatSelection: buildSortByItemTemplate,
            matcher: wsdUtils.trimInitSpaces
        };
        c.sortByDisabled = false;
    }

    /**
     * undo changes and go back to edit reservation details page. Callable on unavailable selection
     */
    function undoChangesAndBackToReservation() {
        var targetPageId = c.options.reservation_page_id ? c.options.reservation_page_id : DEFAULT_RESERVATION_PAGE_ID;
        var pageParam = {
            id: targetPageId,
            reservation_id: c.reservation.sys_id
        };

        // redirect to the target reservation page
        wsdStateService.setPageState('currentReservation', pageParam, false);
        return;
    }

    /**
     * Handles the sort change
     */
    function onSortByChange() {
        wsdStateService.setState('updatedReservableData', {
            updatedReservables: {},
            updatedFavoritesCount: 0
        });

        var reservationPath = wsdStateService.getState('reservationPath');
        var pathSortByObj = wsdStateService.getState('searchSortBy');
        pathSortByObj[reservationPath] = c.sortBy;
        wsdStateService.setState('searchSortBy', pathSortByObj);
        _triggerSearch();
    }

    /**
     * Builds the html for the sort by options
     * @param {SortByOption} item Sort By option to render html for
     * @returns {string}
     */
    function buildSortByItemTemplate(item) {
        // Needs inline style because the select2 is rendered outside our widget, so we cannot style it though css.
        if (c.isNative)
            return wsdUtils.formatString('<span title="{0}" aria-label="{0}">{1}</span>', item.hint, item.text);

        return wsdUtils.formatString('<span title="{0}" aria-label="{0}">{1}<i class="fa {2}" style="margin-left: 10px;"></i></span>', item.hint, item.text, item.icon);
    }

    /**
     * Triggers the search and sets the current building that is searched
     * @param {integer} index of the building being searched in the list of buildings(searchBuildingList)
     */
    function searchFromBuildingStrip(index) {
        wsdStateService.setState("searchBuildingIndex", index, true);

        c.prBuildingTz = c.searchBuildingList[0].building.timezone.value;
        c.secBuildingTz = c.searchBuildingList[index].building.timezone.value;

        c.selectedBuildingToSearch = c.searchBuildingList[index].building;

        wsdStateService.setState('updatedReservableData', {
            updatedReservables: {},
            updatedFavoritesCount: 0
        });
        _triggerSearch(c.activeView.type, false, true, true);
    }

    /*
     * Tracks the scroll position of multi building strip 
     * to determine whether to show the chevron buttons	
     */
    var scrollLeftPosition = 0;
    /**
     * Decides if the scroll arrow should be shown for the building strip
     * @param {string} scrollArrow - if its left arrow or right arrow
     */
    function canShowScrollForBuildingStrip(scrollArrow) {
        var clientWidth = $('.building-strip >.row')[0].clientWidth;
        var scrollWidth = $('.building-strip >.row')[0].scrollWidth;

        var scrollLeft = $('.building-strip >.row')[0].scrollLeft;

        if (scrollArrow == "right") {
            c.canScrollRight = (scrollWidth > (scrollLeftPosition + clientWidth));
            return c.canScrollRight;
        } else {
            c.canScrollLeft = (scrollLeftPosition) > 0;
            return c.canScrollLeft;
        }
    }

    var scrollDebounce = _.debounce(function() {
        canShowScrollForBuildingStrip("right");
        canShowScrollForBuildingStrip("left");
    }, 500);

    /**
     * Show the building strip only when searchBuildingList length > 0 and no empty building exists in the array
     * 
     */
    function showBuildingStrip() {
        return c.searchBuildingList.length > 1 &&
            c.searchBuildingList.filter(function(item) {
                return item.building.value == ''
            }).length < 1;
    }

    /**
     * Performs scroll operation
     * @param {string} scrollDirection - indicates if scroll is needed to left or right
     */
    function scrollBuildingStrip(scrollDirection) {
        var clientWidth = $('.building-strip >.row')[0].clientWidth;
        var scrollWidth = $('.building-strip >.row')[0].scrollWidth;

        var cardWidth = $(".building-card").outerWidth();
        var leftScrollAmt = 0 - cardWidth;
        if (scrollDirection == 'left') {
            // Scroll to left
            $('.building-strip >.row')[0].scrollBy(leftScrollAmt, 0);
            scrollLeftPosition = scrollLeftPosition - cardWidth;
        } else if (scrollDirection == 'right') {
            // Scroll to right
            $('.building-strip >.row')[0].scrollBy(cardWidth, 0);
            scrollLeftPosition = scrollLeftPosition + cardWidth;
        }

        if (scrollDirection == "right") {
            c.canScrollRight = (scrollWidth > (scrollLeftPosition + clientWidth));
        } else {
            c.canScrollLeft = (scrollLeftPosition) > 0;
        }
    }

    /**
     * toggle between view type, and set resultViewType state
     * @param {object} viewOption
     * @param {boolean} ignoreTriggerSearch - should trigger search
     */
    function toggleViewOption(viewOption, ignoreTriggerSearch) {

        if (!viewOption) {
            wsdStateService.setState('resultViewType', null);
            c.activeView = {};
            return;
        }

        c.previousView = Object.assign({}, c.activeView);
        c.activeView = viewOption;
        c.sortByDisabled = c.activeView.type === 'map';
        wsdStateService.setState('resultViewType', viewOption.type);

        // Appsee - wsd event for switching between views
        if ((c.previousView.type != c.activeView.type) && c.previousView.type) {
            var appseeData = {};
            appseeData["Old View"] = c.previousView.type;
            appseeData["New View"] = c.activeView.type;
            appseeData["Mode"] = c.isEditing ? 'Edit' : 'New';
            createAppseeEvent('Switch view', appseeData);
        }

        if (ignoreTriggerSearch)
            return;

        var resetFilterForMap = false;
        if (viewOption.type === 'map')
            resetFilterForMap = true;

        wsdStateService.setState('updatedReservableData', {
            updatedReservables: {},
            updatedFavoritesCount: 0
        });
        _triggerSearch(viewOption.type, false, false, resetFilterForMap);

        wsdUtils.voiceOver(viewOption.label + " ${has been selected}");

        var showingResults = document.getElementById("showing-results");

        $timeout(function() {
            showingResults.innerHTML = "${Showing} " + c.mappedReservables.length + " ${results}";
        }, 500);
    }

    /**
     * Toggle the reservable filter
     */
    function toggleReservableFilter() {
        c.showReservableFilter = !c.showReservableFilter;
        spUtil.setPreference('sn_wsd_rsv.expand_collapse_filter_state', c.showReservableFilter.toString());

        if (c.showReservableFilter)
            setFocusToReservableFilter();

        _evaluateScheduleViewSteps();

        if (c.activeView.type == 'map') {
            if (c.mapType == c.MAP_TYPE.MAPPEDIN) {
                resetMappedinMap();
            } else if (c.mapType == c.MAP_TYPE.INDOOR_MAPS) {
                //TODO: implement reset view method.
            }
        }
    }

    function checkKey(event) {
        if (event.keyCode === 13) {
            toggleReservableFilter();
        } else if (c.showReservableFilter && event.keyCode === 9) {
            event.preventDefault();
            setFocusToReservableFilter();
        }
    }

    /**
     * Sets the focus to the first focusable element in the reservable filter.
     */
    function setFocusToReservableFilter() {
        var reservableFilterElement = document.querySelector('wsd-reservable-filter');
        var firstFocusableReservableFilterElement = getFirstFocusableItem(reservableFilterElement);
        if (firstFocusableReservableFilterElement)
            $timeout(function() {
                firstFocusableReservableFilterElement.focus();
            }, 100);
    }

    /**
     * Gets the first focusable html element, if not found returns null.
     * @param {HTMLElement} [element] - The root element from which to search, if non provided will use document
     * @returns {HTMLElement | null}
     */
    function getFirstFocusableItem(element) {
        element = element || document;
        return element.querySelector('a[href], button, input, textarea, select, details, [tabindex]:not([tabindex="-1"])');
    }

    /**
     * Reset the map.
     */
    function resetMappedinMap() {
        CustomEventManager.fireAll('wsd.mappedin_map.actions', {
            action: "reset_map_view"
        });
    }

    /**
     * Returns whether or not the location (building) can be changed
     * @returns {boolean}
     */
    function isChangeLocationDisabled() {
        return c.isEditing && c.reservation;
    }

    /**
     * notify search provider to research
     * @param {string} viewType - view type (card or schedule), if not given, the last known view type will be used
     * @param {boolean} isPaginationSearch - whether the it's a new search or pagination
     * @param {boolean} [clearFilter] - clear out the reservable filter data before executing the search
     * @param {boolean} searchAction - indicates the kind of search action like refresh/search etc
     * @private
     */
    function _triggerSearch(viewType, isPaginationSearch, clearFilter, clearFloorFilter, searchAction) {
        viewType = viewType ? viewType : wsdStateService.getState('resultViewType');
        var searchOption = {
            viewType: viewType,
            isPaginationSearch: isPaginationSearch,
            pageSize: c.options.page_size
        };
        if (c.scheduleViewDate)
            searchOption.scheduleViewDate = c.scheduleViewDate;

        if (searchAction)
            searchOption.action = searchAction;

        if (clearFloorFilter)
            _resetFloorFiltersForMap();

        if (clearFilter)
            _resetReservableFilterData();

        wsdStateService.setState('triggerSearch', searchOption);
    }

    /**
     * clear out the reservation basket if a different building is being selected.
     * @private
     */
    function _validateReservationBasket() {
        if (c.selectedItems.length === 0)
            return;
        var searchReqObj = wsdStateService.getState('searchRequestObj');
        var currentSelectedBuilding = searchReqObj.building;
        var selectedItemBuilding = c.selectedItems[0].building.sys_id;
        if (selectedItemBuilding != currentSelectedBuilding) {
            wsdReservationBasket.clear();
            wsdStateService.setState('clearedSelection', true);
        }
    }

    /**
     * clear out the floor filter when switching to map view but maintain other filters
     * @private
     */
    function _resetFloorFiltersForMap() {
        var activeFilter = wsdStateService.getState('activeReservableFilter');
        var reservableFilter = wsdStateService.getState('reservableFilter');

        if (activeFilter) {
            var capacity = reservableFilter.capacity;
            var standardServices = reservableFilter.standard_services;
            var reservablePurposes = reservableFilter.reservable_purposes;

            var newFilter = {
                floors: '',
                standard_services: standardServices,
                reservable_purposes: reservablePurposes,
                capacity: capacity
            };

            var floors = activeFilter.filter.floors;
            for (var i = 0; i < floors.length; i++) {
                floors[i].selected = false;
            }

            wsdStateService.setState('activeReservableFilter', activeFilter);
            wsdStateService.setState('reservableFilter', newFilter);
            c.filterCount = 0;
        }
    }

    /**
     * to validate any other reservable other than current is selected
     * @param {Reservable} reservable - reservable to validate
     */

    function isAnyOtherItemSelected(reservable) {
        reservable.is_selected = wsdReservationBasket.isSelected(reservable.sys_id);
        return (!reservable.is_selected && c.isAnyItemSelected);
    }

    /**
     * select or deselect reservable, then resolve selection items
     * @param {Reservable} reservable - reservable to toggle selection
     * @param {*} event
     */
    function toggleReservableSelection(reservable, event) {

        if (event)
            event.preventDefault();

        // Appsee - wsd event when user add/removes spaces on schedule view
        if (c.activeView.type === 'schedule') {
            var resAction = reservable.is_selected ? "Remove" : "Add";
            var appseeData = {};
            appseeData["Action"] = resAction;
            appseeData["Mode"] = c.isEditing ? 'Edit' : 'New';
            createAppseeEvent('Added/Removed spaces', appseeData);
        }



        // once any item item is selected as recurring, other items cannot be selected
        // once an unavailable space is deselected it can not be re-added
        if ((isAnyOtherItemSelected(reservable) && (c.isOccurrence || c.isRecurring)) || (!reservable.is_available && !reservable.is_selected))
            return;

        if (!reservable.is_selected) {
            var addedMessage = wsdUtils.formatString(c.data.translations.itemAddedToBasket, reservable.name);
            wsdUtils.voiceOver(addedMessage);
            c.previouslySelected[reservable.sys_id] = true;
        } else {
            var removedMessage = wsdUtils.formatString(c.data.translations.itemRemovedFromBasket, reservable.name);
            wsdUtils.voiceOver(removedMessage);
            c.previouslySelected[reservable.sys_id] = false;
        }

        // update selected ids list
        wsdReservationBasket.toggle(reservable.sys_id);
        _handleBuildingReservableSelectedCount(reservable);
    }

    /**
     * handles the count of selected items in the building strip
     * @param {Reservable} reservable 
     * @param {boolean} unselectAll - clear all the items selected 
     */
    function _handleBuildingReservableSelectedCount(reservable, unselectAll) {
        if (_.isEmpty(c.searchBuildingList)) {
            return;
        }
        if (unselectAll) {
            c.searchBuildingList.forEach(function(element, index) {
                c.searchBuildingList[index].selectedCount = 0;
                c.searchBuildingList[index].countLabel = '${No item selected}';
            });
            c.selectedItems = [];
            wsdStateService.setState('searchBuildingList', c.searchBuildingList);
            return;
        }

        var indexOfBuildingToUpdateCount = c.searchBuildingList.findIndex(function(element) {
            return element.building.value == reservable.building.sys_id;
        })
        if (indexOfBuildingToUpdateCount != -1) {
            var is_reservable_selected = wsdReservationBasket.isSelected(reservable.sys_id);
            if (is_reservable_selected)
                c.searchBuildingList[indexOfBuildingToUpdateCount].selectedCount++;
            else
                c.searchBuildingList[indexOfBuildingToUpdateCount].selectedCount--;
            var selectedCount = c.searchBuildingList[indexOfBuildingToUpdateCount].selectedCount;
            c.searchBuildingList[indexOfBuildingToUpdateCount].countLabel = _constructCountLabel(selectedCount);
            wsdStateService.setState('searchBuildingList', c.searchBuildingList);

        } else
            console.error("Building of the reservable is not present in list of buildings to search!")
    }

    /**
     * remove selected reservable, on click of pill in selected items bar
     * @param {string} id - sys_id of the reservable
     * @param {Reservable} reservable - reservable to toggle selection
     */
    function removeSelectedItem(id, reservable) {
        toggleReservableSelection(reservable);
        if (c.activeView.type === 'map' && c.mapType === c.MAP_TYPE.INDOOR_MAPS) {
            var spaceExternalId = c.wsdIndoorMapAvailabilityData.spaceToExternalId.get(reservable.sys_id);
            if (c.cardData) {
                c.cardData.actions = c.cardData.extraData.cardActions;
            }
            if (c.cardData && reservable.sys_id === c.cardData.sysId) {
                applyStyle(spaceExternalId, c.indoorMapSpaceDecoration.available);
                indoorMapObj.highlightPlace(spaceExternalId);
            } else {
                applyStyle(spaceExternalId, c.indoorMapSpaceDecoration.available);
            }
        }
    }

    /**
     * callback action to be performed when the button is clicked on the Reservable Unit Cards
     * @param {Action} action - add/remove action on click of the card actions
     * @param {string} id - sys_id of the reservable
     * @param {Reservable} reservable - reservable to toggle selection
     */
    function cardActionsCallback(action, id, reservable) {

        // Appsee - wsd event for select/unselect room on map view and card view
        if (c.activeView.type === 'map' || c.activeView.type === 'card') {
            var appseeData = {};
            appseeData['Action'] = action.displayValue;
            appseeData["Mode"] = c.isEditing ? 'Edit' : 'New';
            createAppseeEvent('Added/Removed spaces', appseeData);
        }

        toggleReservableSelection(reservable);
        if (c.activeView.type === 'map' && c.mapType === c.MAP_TYPE.INDOOR_MAPS) {
            if (c.cardData) {
                c.cardData.actions = c.cardData.extraData.cardActions;
            }
            if (action.value === 'add') {
                indoorMapObj._highlightPlace(reservable.external_id, c.indoorMapSpaceDecoration.selected);
                applyStyle(reservable.external_id, c.indoorMapSpaceDecoration.selected);
            } else if (action.value == 'remove') {
                indoorMapObj.highlightPlace(reservable.external_id);
                applyStyle(reservable.external_id, c.indoorMapSpaceDecoration.available);
            }
        }
    }

    /**
     * de-select all selected items
     */
    function unSelectAll() {
        var selectedIds = wsdReservationBasket.getSelectedIds();
        Object.keys(c.previouslySelected).forEach(function(spaceId) {
            c.previouslySelected[spaceId] = false;
        })
        if (c.activeView.type === 'map' && c.mapType === c.MAP_TYPE.INDOOR_MAPS) {
            selectedIds = wsdReservationBasket.getSelectedIds();
            selectedIds.forEach(function(spaceId) {
                var spaceExternalId = c.wsdIndoorMapAvailabilityData.spaceToExternalId.get(spaceId);
                if (spaceExternalId) {
                    applyStyle(spaceExternalId, c.indoorMapSpaceDecoration.available);
                }
            })
            wsdReservationBasket.clear();

            if (c.cardData) {
                c.cardData.actions = c.cardData.extraData.cardActions;
                indoorMapObj.highlightPlace(c.cardData.externalId);
            }
        } else {
            wsdReservationBasket.clear();
        }

        c.showAllSelectedReservables = false;
        _handleBuildingReservableSelectedCount(null, true);

    }
    /**
     * reserve a single reservable
     * @param {string} reservableId - sys_id of the target reservable
     */
    function reserveReservable(reservableId) {
        processToReserve([reservableId]);
    }

    /**
     * reserve multiple reservables (multi-child reservation)
     */
    function reserveReservables() {

        // Appsee - wsd event when proceeding to details page
        var appseeData = {};
        appseeData["Mode"] = c.isEditing ? 'Edit' : 'New';
        createAppseeEvent('Proceed to details page', appseeData);

        var recurringPattern = wsdStateService.getState('recurringPattern');
        var isSingleReservation = false;
        if (recurringPattern) {
            if (recurringPattern.repeats === 'daily' || recurringPattern.repeats === 'monthly') {
                if (recurringPattern.options.count < 2) {
                    isSingleReservation = true;
                }
            } else if (recurringPattern.repeats === 'weekly') {
                if (recurringPattern.options.daysOfWeek && recurringPattern.options.daysOfWeek.length < 2) {
                    if (recurringPattern.options.count < 2) {
                        isSingleReservation = true;
                    }
                }
            }
        }

        var reservableIds = c.selectedItems.map(function(item) {
            return String(item.sys_id);
        });
        if (c.selectedItems.length > 1 || isSingleReservation)
            wsdStateService.setState('recurringPattern', null);

        //In case of multi building selection show a confirm dialog box in case there are buildings with no spaces selected
        if (!_.isEmpty(c.searchBuildingList) && c.searchBuildingList.length > 1) {
            var isPrimaryBuilding = false;
            if (c.searchBuildingList[0].selectedCount === 0) {
                isPrimaryBuilding = true;
            }

            var buildingsWithNoSpacesSelected = [];
            buildingsWithNoSpacesSelected = c.searchBuildingList.filter(function(element) {
                return element.selectedCount <= 0;
            });

            if (buildingsWithNoSpacesSelected.length > 0) {
                var confirmationModal = openConfirmModal(buildingsWithNoSpacesSelected, isPrimaryBuilding);
                confirmationModal.then(function(element) {
                    processToReserve(reservableIds);
                }, function(dismissReason) {
                    if (dismissReason === 'make_selection')
                        console.log("Staying in search page to make selection in other buildings")
                });
            } else
                processToReserve(reservableIds);
        } else
            processToReserve(reservableIds);
    }

    /**
     * opens a confirm modal when there are buildings with no spaces selected
     * @param {array} buildingsWithNoSpacesSelected - list of buildings that do not have any spaces selected
     */
    function openConfirmModal(buildingsWithNoSpacesSelected, isPrimaryBuilding) {
        var modalInstance = $uibModal.open({
            templateUrl: 'wsdConfirmDialog',
            controller: _modalInstanceCtrl,
            controllerAs: 'modalDetails',
            resolve: {
                buildingsWithNoSpacesSelected: function() {
                    return buildingsWithNoSpacesSelected;
                },
                isPrimaryBuilding: function() {
                    return isPrimaryBuilding;
                }
            }
        });

        return modalInstance.result;
    }

    /**
     * Controller for uib modal
     * @private
     */
    function _modalInstanceCtrl($uibModalInstance, buildingsWithNoSpacesSelected, isPrimaryBuilding) {
        var modalDetails = this;
        var buildingName = buildingsWithNoSpacesSelected[0].building.displayValue;
        modalDetails.title = isPrimaryBuilding ? "${Select a space to reserve in }" + buildingName : '${Continue without selecting spaces?}';
        modalDetails.cancelTitle = '${No}';
        modalDetails.cancelCallbackFunction = stayOnSearchPage;
        modalDetails.confirmTitle = '${Yes}';
        modalDetails.confirmCallbackFunction = closeModal;
        modalDetails.hideActions = isPrimaryBuilding;
        modalDetails.message = _constructModalBody();

        function _constructModalBody() {
            if (isPrimaryBuilding) {
                var buildingName = buildingsWithNoSpacesSelected[0].building.displayValue;
                return wsdUtils.formatString("{0} ${is the primary building for your reservation because it was your first building selection. To continue with your reservation, you'll have to select a space in this building.}", buildingName)
            } else {
                var buildingsList = []
                for (var building = 0; building < buildingsWithNoSpacesSelected.length; building++) {
                    buildingsList.push(buildingsWithNoSpacesSelected[building].building.displayValue + ", " + buildingsWithNoSpacesSelected[building].building.campusName);
                }
                if (buildingsList.length == 1)
                    return $sce.trustAsHtml(wsdUtils.formatString("${The following building(s) do not have any spaces selected.} <ul style=\"padding-left:15px\"><li>" +
                        buildingsList[0] +
                        " </li></ul>${Do you want to continue without selecting spaces in this building?}"));
                else
                    return $sce.trustAsHtml(wsdUtils.formatString("${The following building(s) do not have any spaces selected.} <ul style=\"padding-left:15px\"><li>" +
                        buildingsList.join('</li><li>') +
                        '</li></ul>${Do you want to continue without selecting spaces in these buildings?}'));
            }
        }

        function stayOnSearchPage() {
            $uibModalInstance.dismiss('make_selections');
        }

        function closeModal() {
            $uibModalInstance.close();
        }

    }

    /**
     * open the reservation page, or send data to the reservation widget on the same page depending on widget options
     * @param {string[]} reservableIds - an array of string ids
     */
    function processToReserve(reservableIds) {
        var searchRequestObj = wsdStateService.getState('searchRequestObj');
        var recurringPattern = wsdStateService.getState('recurringPattern');
        var primarybuilding = c.searchBuildingList[0].building.value;

        var targetPageId = c.options.reservation_page_id ? c.options.reservation_page_id : DEFAULT_RESERVATION_PAGE_ID;

        var pageParam = {
            id: targetPageId,
            reservable_ids: reservableIds.join(','),
            start: searchRequestObj.start,
            end: searchRequestObj.end,
            timezone: searchRequestObj.timezone,
            primary_building: primarybuilding,
            neighborhood: searchRequestObj.neighborhood,
            reservation_path: searchRequestObj.rsv_path,
            ignore_same_day_validation: searchRequestObj.ignore_same_day_validation,
            all_day: searchRequestObj.all_day
        };

        if (recurringPattern !== null) {
            pageParam.recurring_pattern = encodeURI(JSON.stringify(recurringPattern));
            var reservable = c.mappedReservables.filter(function check(x) {
                return (x.sys_id == reservableIds)
            });
            if (reservable.length > 0 && reservable[0].availabilityScore) {
                pageParam.availability_score = reservable[0].availabilityScore.score;
            }
        }

        if (c.mode === 'edit')
            pageParam.reservation_ids = searchRequestObj.reservation_ids;
        else
            pageParam.reservable_module = searchRequestObj.reservable_module;

        var shiftId = searchRequestObj.shift;
        if (shiftId)
            pageParam.shift_id = shiftId;

        // redirect to the target reservation page
        wsdStateService.setPageState('currentReservation', pageParam, false);
    }

    /**
     * listen to searching status changes
     */
    function _createSearchingStateWatcher() {
        var toWatch = 'searching';
        if (c.watcher[toWatch])
            return;

        c.watcher[toWatch] = wsdStateService.subscribe(toWatch, function(old, searchingState) {
            c.searching = searchingState;
            c.wasSearched = true;
            c.searchWasAuto = wsdStateService.getState('searchWasAuto');

            var selectedModule = wsdStateService.getState('selectedReservableModule');
            if (selectedModule) {
                c.shiftMode = selectedModule.apply_to_shift;

                c.viewOptions = selectedModule.reservable_views;
                if (wsdStateService.getState('reservableModuleChangedAfterSearch')) {
                    if (!c.data.isMesp)
                        toggleViewOption(wsdUtils.getDefaultReservableView(c.viewOptions), true);
                    else
                        toggleViewOption(wsdUtils.getMobileReservableView(c.viewOptions, MOBILE_VIEW), true);
                }
            }

            if (c.searchWasAuto)
                c.autoSearchResultSubTitle = wsdStateService.getState('autoSearchResultSubTitle');
            //Showing Notication in case of nearby search. 
            var reservationPath = wsdStateService.getState('reservationPath');
            if (reservationPath === BROWSE_NEAR_A_PERSON) {
                var userReservedLocMessage = wsdUtils.formatString(c.data.translations.nearbyUserSearchResultNotification, wsdStateService.getState('nearbyUser') ? wsdStateService.getState('nearbyUser').displayValue : '', wsdStateService.getState('selectedUserReservedLoc') ? wsdStateService.getState('selectedUserReservedLoc').displayValue : '')
                _showNotification(false, userReservedLocMessage, 'alert-info', 'fa-map-marker');
            }
        });
    }

    /**
     * listen to isRecurring flag changes
     */
    function _createIsRecurringWatcher() {
        var toWatch = 'isRecurring';
        if (c.watcher[toWatch])
            return;

        c.watcher[toWatch] = wsdStateService.subscribe(toWatch, function(old, isRecurring) {
            c.isRecurring = isRecurring;

            if (old !== isRecurring && (c.isRecurring && c.selectedItems.length > 1)) {
                unSelectAll();
            }
        });
    }

    /**
     * Display a notification if the user changed search settings without searching again results deviate so the users should be made aware
     * @private
     */
    function _createResultsFitSearchWatcher() {
        var watcherId = 'resultsDeviate';
        if (c.watcher[watcherId])
            return;

        c.watcher[watcherId] = wsdStateService.subscribe(watcherId, function(old, deviates) {
            if (deviates && !wsdStateService.getState('settingAutoSearchValues')) {
                c.resultDeviates = true;
                _showSearchDeviatesNotification();
            } else {
                _removeNotification();
                c.resultDeviates = false;
            }
        });
    }

    /**
     * Display a notification if there is an overlapping reservation for the user
     * @private
     */
    function _createOverlappingRsvWatcher() {
        var watcherId = 'overlapped';
        if (c.watcher[watcherId])
            return;

        c.watcher[watcherId] = wsdStateService.subscribe(watcherId, function(old, overlapped) {
            if (overlapped)
                _showOverlappingRsvNotification();
            else
                _removeNotification();
        });
    }

    /**
     * availableReservables is triggered once reservables are loaded based on a search query
     * @private
     */
    function _createReservableWatcher() {
        var toWatch = 'availableReservables';
        if (c.watcher[toWatch])
            return;

        c.watcher[toWatch] = wsdStateService.subscribe(toWatch, function(old, reservables) {

            // monitor filters to retest availability of selected spaces upon change
            var searchRequestObj = wsdStateService.getState('searchRequestObj');
            wsdReservationBasket.setFilterConstraints({
                start_at: moment(searchRequestObj.start),
                end_at: moment(searchRequestObj.end),
                building_id: searchRequestObj.building,
                reservable_module_id: searchRequestObj.reservable_module,
                shift_id: searchRequestObj.shift,
                reservation_ids: searchRequestObj.reservation_ids ? searchRequestObj.reservation_ids.split(',') : null,
                timezone: searchRequestObj.timezone,
                ignore_same_day_validation: searchRequestObj.ignore_same_day_validation || false

            });
            _resolveReservablesResult(reservables);
            _evaluateAvailabilityResult(reservables);

            // inform the view to refresh accordingly
            wsdStateService.setState('mappedReservables', c.mappedReservables);
            wsdStateService.setState('refreshView');
        });
    }

    function _getAndMapFavoriteWidgets(mappedReservables) {
        if (c.activeView.type === 'map')
            return;

        //clearing off the cached favorites to trigger the fav call to update the favorites done from the Map View
        if (c.previousView && c.previousView.type == 'map')
            c.reservablesFavWidgets = {};

        // assign cached favWidgets to old spaces 
        _mapFavoriteWidgetsToReservables(mappedReservables, c.reservablesFavWidgets);
        // get favWidgets for new spaces
        var favDataForReservablesWithEmptyFavWidget = _getFavDataForReservablesWithEmptyFavWidget(mappedReservables);
        favDataForReservablesWithEmptyFavWidget && favDataForReservablesWithEmptyFavWidget.length > 0 && c.data.isFavoritesEnabled && c.server.get({
            action: 'getFavoriteWidgets',
            reservablesFavData: favDataForReservablesWithEmptyFavWidget
        }).then(function(response) {
            var favoriteWidgets = response && response.data && response.data.favoriteWidgets;
            // cache favWidgets
            Object.assign(c.reservablesFavWidgets, favoriteWidgets);
            _mapFavoriteWidgetsToReservables(mappedReservables, favoriteWidgets);
        });
    }

    function _mapFavoriteWidgetsToReservables(mappedReservables, favoriteWidgets) {
        if (favoriteWidgets && Object.keys(favoriteWidgets).length > 0 && mappedReservables && mappedReservables.length > 0) {
            mappedReservables.forEach(function(reservable) {
                if (!reservable.favoriteWidget)
                    reservable.favoriteWidget = favoriteWidgets[reservable.sys_id];
            });
        }
    }

    function _getFavDataForReservablesWithEmptyFavWidget(reservables) {
        return reservables && reservables.length > 0 && reservables.filter(function(reservable) {
            return !reservable.favoriteWidget && reservable.favorite && reservable.favorite.tableName;
        }).map(function(reservable) {
            return {
                "tableName": reservable.favorite.tableName,
                "sysId": reservable.favorite.id || reservable.sys_id,
                "isFavorite": reservable.favorite.isFavorite,
            };
        });
    }

    /**
     * Creates watcher for when the shift start end time changes. Needed to display schedule view properly.
     * @private
     */
    function _createShiftTimeSpanWatcher() {
        var toWatch = 'shiftTimeSpan';
        if (c.watcher[toWatch])
            return;

        c.watcher[toWatch] = wsdStateService.subscribe(toWatch, function(oldShiftStartEnd, newShiftStartEnd) {
            var searchRequestObj = wsdStateService.getState('searchRequestObj');
            if (newShiftStartEnd) {
                c.selectedStartDate = {
                    value: moment.utc(newShiftStartEnd.start).tz(searchRequestObj.timezone)
                };
                c.selectedEndDate = {
                    value: moment.utc(newShiftStartEnd.end).tz(searchRequestObj.timezone)
                };
            } else {
                c.selectedStartDate = null;
                c.selectedEndDate = null;
            }
        });
    }

    /**
     * Calc the amount of selected filters from the reservable filter directive
     * @private
     */
    function _createFilterCountWatcher() {
        var toWatch = 'triggerFilterCount';
        if (c.watcher[toWatch])
            return;

        c.watcher[toWatch] = wsdStateService.subscribe(toWatch, function(old, filterCountObj) {
            // when amount is send as 0, it indicates a reset of the filter
            if (filterCountObj.amount === 0)
                return c.filterCount = 0;
            else if (filterCountObj.amount > 0)
                return c.filterCount = filterCountObj.amount;

            filterCountObj.add ? c.filterCount += 1 : c.filterCount -= 1;
        });
    }

    /**
     * evaluate and check if the selected reservable is still available
     * @param {Reservable[]} reservables
     * @private
     */
    function _evaluateAvailabilityResult(reservables) {
        if (!c.isEditing || !reservables)
            return;

        // first check if there is any mismatched reservables
        var hasMismatched = reservables.some(function(reservable) {
            return reservable.is_mismatched;
        });

        if (hasMismatched) {
            _setMismatchSearchNotitication(true);
            return;
        }

    }

    /**
     * Display a notification to the user containing information related to the state of the search
     * @param {boolean} hasError - indicates whether this is an error notification
     * @param {string} [msg] - message that should be displayed to the end user
     * @param {string} [type] - type of notification that should be displayed (success, info, warning, danger)
     * @param {string} [icon] - icon that should be displayed (e.g., fa-info-circle)
     * @private
     */
    function _showNotification(hasError, msg, type, icon) {
        c.hasError = hasError;
        msg = msg ? msg : '${An error has occurred. Please try again}';
        c.notificationConfig = {
            msg: msg,
            type: type,
            icon: icon
        };
        c.showNotification = true;
    }

    /**
     * Removes an notification
     * @private
     */
    function _removeNotification() {
        c.notificationConfig = {};
        c.showNotification = false;
    }

    /**
     * displays a notification, that user has an overlapping reservation
     * @private
     */
    function _showOverlappingRsvNotification() {
        var msg = "${It looks like you have another reservation during this time. You may want to review reservations before continuing.}";
        c.notificationConfig = {
            msg: msg,
            type: 'alert-warning',
            icon: 'fa-warning',
            callbackText: '${View reservations}',
            callback: function() {
                wsdUtils.openPage("wsd_reservations");
            }
        };
        c.showNotification = true;
    }

    /**
     * displays a notification, that search does not match results where user can click to get new results
     * @private
     */
    function _showSearchDeviatesNotification() {
        var msg = "${You've updated the search criteria.}"; //escaping quote doesn't work in translation, therefore using double quote for defining this string
        c.notificationConfig = {
            msg: msg,
            type: 'alert-info',
            icon: 'fa-info-circle',
            callbackText: '${Refresh the results}',
            callback: function() {
                c.searchWasAuto = false;
                wsdStateService.setState('updatedReservableData', {
                    updatedReservables: {},
                    updatedFavoritesCount: 0
                });
                wsdStateService.setState('searchWasAuto', false, true);
                var searchAction = "refresh";
                _triggerSearch(null, false, true, undefined, searchAction);
            }
        };
        c.showNotification = true;
    }

    /**
     * displays a notification, the profiled module is invalid or unavailable
     * @private
     */
    function _showInvalidModuleNotification() {
        var msg = '${The requested reservable type is not available, please select a different one to create the reservation}.';
        c.notificationConfig = {
            msg: msg,
            type: 'alert-warning',
            icon: 'fa-exclamation-triangle'
        };
        c.showNotification = true;
    }

    /**
     * set mismatched reservables data and the search filter. Used in edit mode
     * @param {boolean} hasMismatched - if there is any mismatched reservable compare to search filter.
     * @private
     */
    function _setMismatchSearchNotitication(hasMismatched) {
        if (!hasMismatched) {
            c.editInfo = {
                hasAvailabilityError: false
            };
            return;
        }

        var msg = '${Your reserved item does not match the search criteria. You can choose another one, or undo the changes}.';

        if (c.isMultiItemSelection)
            var msg = '${One of your reserved items do not match the search criteria. You can choose another one, or undo the changes}.';

        var actionText = '${Click to undo}.';

        c.editInfo = {
            hasAvailabilityError: true,
            msg: msg,
            actionText: actionText
        };
    }

    /**
     * set availability notification. Used in edit mode
     * @param {boolean} hasAvailabilityError - indicates whether the selected item is still available
     * @private
     */
    function _setAvailabilityNotification(hasAvailabilityError) {
        var msg = hasAvailabilityError ?
            '${One or more selected items are unavailable for the time you have selected. You can choose another one, or undo the changes}.' :
            '${The selected item(s) are available. You can choose another one, or undo the changes}.';

        var actionText = hasAvailabilityError ?
            '${Click to undo}.' :
            '${Go back to my reservation}.';

        c.editInfo = {
            hasAvailabilityError: hasAvailabilityError,
            msg: msg,
            actionText: actionText
        };
    }

    function _addLabelsToIconsAndConstructRsvUsersData(reservables) {
        var isScheduleView = c.activeView.type === 'schedule';
        reservationData = [];
        var iconLabels = {
            capacity: '${Capacity}',
            standard_services: '${Includes}',
            reservable_purposes: '${Tags}'
        };
        reservables.forEach(function(reservable) {
            reservable.body.forEach(function(item) {

                if (!isScheduleView && item.field === 'capacity') {
                    item.displayValue = ['${Seats}', item.displayValue].join(' ');
                }
                if (reservable.reservations) {
                    var externalId = reservable.external_id;
                    if (externalId && reservable.reservations[0]) {
                        reservationData.push({
                            "external_id": externalId,
                            "reserved_user_name": reservable.reservations[0].requested_for.name
                        });
                    }
                }
                item.iconLabel = iconLabels[item.field];
            });
        });
    }

    /**
     * resolve and prepare reservables for result view.
     * @param {Reservable[]} reservables - list of the reservable result.
     * @param {boolean} [isInitialLoad] - defaults to false, should be true once its called in initial load
     * @private
     */
    function _resolveReservablesResult(reservables, isInitialLoad) {
        resetIndoorMapCardData(undefined);
        var resultViewType = wsdStateService.getState('resultViewType');

        if (!resultViewType) {
            _showNotification(false, '${Reservable module has no associated views, contact the application admin.}', 'alert-warning', 'fa-exclamation-triangle');
            return;
        }

        resultViewType = resultViewType ? resultViewType : 'card';

        if (!wsdUtils.arrayHasElement(reservables)) {
            // No result - when there are no result or error occurred
            if (c.isEditing)
                _setAvailabilityNotification(true);

            c.mappedReservables = [];
            // Defaulting the value as we do not trigger mountWsdComponent method
            // If there are no reservables available in this building.
            c.missingSpaceMap = false;
            c.hasMore = false;
            var searchResultMsg = wsdStateService.getState('searchResultMsg');
            _setMainResultPanelMsg(false, searchResultMsg);

            if (resultViewType === "map") {
                // We show the map even if there are no reservable items on the floor
                if (c.mapType == c.MAP_TYPE.MAPPEDIN)
                    mountWsdMappedinComponent(null);
                else if (c.mapType == c.MAP_TYPE.INDOOR_MAPS)
                    mountWsdIndoorMapsComponent(null);
                else
                    c.missingSpaceMap = true;
                return;
            } else
                return;
        }

        // When there are reservables
        try {
            // validates that all reservables loaded match the last searched building (Edit mode).
            // If not, those reservables will be made unavailable
            // used mainly when multi reservation is editing and changing building
            var searchRequestObj = wsdStateService.getState('searchRequestObj');

            // Reset the updated reservables (on the current page) so that it won't be considered for the next page call.
            // Otherwise, it would be considered for all next page calls.
            var updatedReservableData = wsdStateService.getState('updatedReservableData');
            if (!updatedReservableData)
                updatedReservableData = {};

            updatedReservableData.updatedFavoritesCount = 0;
            wsdStateService.setState('updatedReservableData', updatedReservableData);
            if (c.isEditing && searchRequestObj && searchRequestObj.building) {
                reservables.forEach(function(reservable) {
                    if (reservable.building && reservable.building.sys_id !== searchRequestObj.building) {
                        reservable.is_available = false;
                        reservable.is_mismatched = true;
                    } else if (c.previouslySelected[reservable.sys_id] && reservable.is_available) {
                        // when in edit mode, day is set to conflicting date, and then set to a non conflicting date it should re-select
                        reservable.is_selected = true;
                        if (!wsdReservationBasket.isSelected(reservable.sys_id) && !(c.isOccurrence && c.isAnyItemSelected)) {
                            wsdReservationBasket.toggle(reservable.sys_id);
                            _handleBuildingReservableSelectedCount(reservable);
                        }
                    }
                })
            }
            if (!isInitialLoad)
                c.initialLoadFoReselectCheck = true;

            // simply check if the search provider actually has more result
            c.hasMore = wsdStateService.getState('searchResultHasMore');
            c.mappedReservables = reservables.map(c.reservableMapper);
            c.scheduleViewStart = c.shiftMode ? c.selectedStartDate : c.start;
            c.scheduleViewEnd = c.shiftMode ? c.selectedEndDate : c.end;
            c.scheduleViewDate = searchRequestObj && searchRequestObj.schedule_view_obj && searchRequestObj.schedule_view_obj.schedule_view_date;
            if (c.mappedReservables.length > 0)
                _addLabelsToIconsAndConstructRsvUsersData(c.mappedReservables);
            _getAndMapFavoriteWidgets(c.mappedReservables);

            if (resultViewType === 'map') {
                if (c.mapType == c.MAP_TYPE.MAPPEDIN)
                    mountWsdMappedinComponent(null);
                else if (c.mapType == c.MAP_TYPE.INDOOR_MAPS)
                    mountWsdIndoorMapsComponent(null);
                else
                    c.missingSpaceMap = true;
            } else if (resultViewType === 'schedule') {
                c.scheduleViewDisplayDate = wsdStateService.getState('scheduleViewDisplayDates');
                _evaluateScheduleViewSteps();
            }

            var origin = isInitialLoad ? 'init' : 'landing';

            if (c.isFromShowMore) {
                $timeout(function() {
                    var nextFocusableEl = document.getElementById(wsdStateService.getState('nextFocusableReservable'));
                    if (nextFocusableEl)
                        resultViewType === 'card' ? nextFocusableEl.querySelector('.horizontal-card__action-button').focus() : nextFocusableEl.querySelector('.reservable-action button').focus();
                });
            }

            c.isFromShowMore = false;

            //In case of browse near a person, validating reservation basket
            var reservationPath = wsdStateService.getState('reservationPath');
            if (reservationPath == BROWSE_NEAR_A_PERSON) {
                _validateReservationBasket();
            }
            _evaluateSelectionAndUpdateFeedback({
                origin: origin
            });
            wsdUtils.voiceOver("${Showing} " + c.mappedReservables.length + " ${results}");

        } catch (ex) {
            console.warn('resolveReservablesResult error', ex);
            c.hasError = true;
            var errorMsg = '${An error has occurred while processing search result. Please try again}';
            _showNotification(true, errorMsg, 'alert-danger', 'fa-exclamation-triangle');
        }
    }



    /**
     * set result message and fetch possible result message (if given)
     * @param {boolean} hasResult - if there is no result, the messeage will be shown
     * @param {string} [resultMessage] when there is no result, and the message is given, it will be displayed, otherwise default message will be used.
     */
    function _setMainResultPanelMsg(hasResult, resultMessage) {
        if (hasResult)
            return;

        // when there is no result
        if (c.isRegularSearch) {
            c.resultMsg.title = '${There are no available results for your search}';
            c.resultMsg.msg = resultMessage ? resultMessage : '${Sorry about that! You can search to reserve something else, or try another time or location.}'
        } else {
            c.resultMsg.title = '${There are no results to display}';
            c.resultMsg.msg = resultMessage ? resultMessage : '${We could not find any available items that match your search. Please try again by applying a different filter criteria.}';
        }
        wsdUtils.voiceOver(c.resultMsg.title);
    }

    /**
     * module watcher is triggered on change of the selected module, and will generate a mapper from reservable
     * definition to tile that will be used on the data of each reservable
     * @private
     */
    function _createModuleWatcher() {
        var toWatch = 'selectedReservableModule';
        if (c.watcher[toWatch])
            return;

        // this state is changed in the wsdSearchFilterDirective
        c.watcher[toWatch] = wsdStateService.subscribe(toWatch, function(old, reservableModule) {
            c.reservableMapper = reservableModule ? reservableModule.reservableMapper : null;
            c.previousView = {};
        });
    }

    /**
     * Reservation Path watcher is triggered on change of the selected Path, and will reset the sortBy options
     * based on the path, and also, clear out the previously selected spaces from search results
     * @private
     */
    function _createReservationPathWatcher() {
        var toWatch = 'reservationPath';
        if (c.watcher[toWatch])
            return;

        // this state is changed in the wsdSearchFilterDirective
        c.watcher[toWatch] = wsdStateService.subscribe(toWatch, function(old, reservationPath) {
            if (old == reservationPath)
                return;
            c.renderSortBy = false;
            if (reservationPath == BROWSE_NEAR_A_PERSON) {
                c.sortBySelect2Options.data = c.sortByOptions[BROWSE_NEAR_A_PERSON];
                c.sortBy = c.sortBySelect2Options.data[0].id;
            } else {
                c.sortBy = wsdStateService.getState('searchSortBy')[reservationPath];
                c.sortBySelect2Options.data = c.sortByOptions[BROWSE_ALL];
            }

            if (old) {
                unSelectAll();
            }
            $timeout(function() {
                c.renderSortBy = true;
            });
        });
    }

    /**
     * create search building list watcher is triggered when there is a refresh/search action performed
     * @private
     */
    function _createSearchBuildingListWatcher() {

        var toWatch = 'searchBuildingList';
        if (c.watcher[toWatch])
            return;

        c.watcher[toWatch] = wsdStateService.subscribe(toWatch, function(old, searchBuildingList) {

            // Reconstruct the building strip only if there is change in list of buildings to search and on initial load
            // We dont construct building strip on initial load of edit as selected items are not avaialable yet

            /* We are constructing on initial load of create because if autoSearch is performed and user wants to go ahead with single reservation 
             * we still want searchBuildingList to be filled, else selected items count update is not reflected in searchFilter for disabling building picker
             */

            var isInitialLoad = !old && searchBuildingList && searchBuildingList.length > 0;

            if (isInitialLoad ? !c.isEditing : c.resultDeviates) {
                if (c.selectedItems.length == 0) {
                    _constructBuildingStrip();
                } else {
                    //List of spaces that are supposed to be deselected because building was removed from the search filter
                    var spacesToRemove = c.selectedItems.filter(function(selectedItem) {
                        return !searchBuildingList.find(function(buildingList) {
                            return buildingList.building.value == selectedItem.building.sys_id;
                        })
                    }).map(function(loc) {
                        return loc.sys_id;
                    });

                    wsdReservationBasket.remove(spacesToRemove);
                    _constructBuildingStrip(c.selectedItems);
                }
                //Setting the current building that is being searched
                c.selectedBuildingToSearch = c.searchBuildingList[0].building;

                //Resetting primary and secondary BuildingTimezones
                c.prBuildingTz = "";
                c.secBuildingTz = "";
                return;
            }
            //In case a search is performed without any changes to search criteria, and the building searched differs from currently searched building (happens when user clicks edits search and doesnt change anything)
            //we reset currentBuildingToSearch to primaryBuilding and reset timezones
            var indexOfBuildingSearched = wsdStateService.getState('searchBuildingIndex');
            if (c.selectedBuildingToSearch && c.searchBuildingList.length > 0 && c.selectedBuildingToSearch.value != c.searchBuildingList[indexOfBuildingSearched].building.value) {

                //Resetting primary and secondary BuildingTimezones
                c.prBuildingTz = "";
                c.secBuildingTz = "";

                //Setting the current building that is being searched
                c.selectedBuildingToSearch = c.searchBuildingList[indexOfBuildingSearched].building;
            }
        });
    }

    /**
     * Watcher is triggered when doing search (both regular and filtered search)
     * will have a value when a filtered search is used, will be empty on regular search
     * @private
     */
    function _createReservableFilterWatcher() {
        var toWatch = 'reservableFilter';
        if (c.watcher[toWatch])
            return;

        c.watcher[toWatch] = wsdStateService.subscribe(toWatch, function(old, reservableFilter) {
            c.isRegularSearch = !reservableFilter;
        });
    }

    /**
     * Adds _evaluateSelectionAndUpdateFeedback as a listener for changes to the
     * selected item basket
     * @private
     */
    function _createReservationBasketWatcher() {
        // Trigger synchronously after items are selected/deselected
        wsdReservationBasket.on('selectionChange', _evaluateSelectionAndUpdateFeedback);
    }

    /**
     * Updates the is_selected flag of the items in mappedReservables and floorReservables
     * if the items are still in the reservation basket
     * @param {EventDetails} evt - the details about the event that caused the change
     * @private
     */
    function _evaluateSelectionAndUpdateFeedback(evt) {
        evt = evt || {};

        if (evt.origin !== 'validation' && evt.origin !== 'navigation' && evt.origin !== 'init')
            _validateSelection(evt.origin);

        // optimistic sync of the is_selected flag for both map and cards (displayed only)
        c.mappedReservables.forEach(function(item) {
            item.is_selected = wsdReservationBasket.isSelected(item.sys_id);
            _setCardActions(item);
        });
        c.floorReservables.forEach(function(item) {
            item.is_selected = wsdReservationBasket.isSelected(item.sys_id);
            _setCardActions(item);
        });

        if (c.activeView.type === 'map') {
            if (c.mapType === c.MAP_TYPE.MAPPEDIN) {
                c.wsdMappedinReservationData = wsdMappedinService.generateAvailabilityIndex(
                    c.floorReservables,
                    new Set(wsdReservationBasket.getSelectedIds())
                );
                c.wsdMappedinReservationData.legends = _getMapLegend();
            } else if (c.mapType === c.MAP_TYPE.INDOOR_MAPS) {
                c.wsdIndoorMapAvailabilityData = wsdIndoorMapService.generateAvailabilityIndex(
                    c.floorReservables,
                    new Set(wsdReservationBasket.getSelectedIds())
                );
            }
        }
    }

    /**
     * Updates the card actions of the items in mappedReservables and floorReservables
     * if the items are still in the reservation basket
     * @param {Reservable} item - Reservable Unit
     * @private
     */
    function _setCardActions(item) {
        item.cardActions = [];
        if (!item.is_available) {
            var addAction = Object.assign({}, c.cardActions.add);
            addAction.isDisabled = true;
            item.cardActions.push(addAction);
        } else if (!item.is_selected) {
            var addAction = Object.assign({}, c.cardActions.add);
            addAction.isDisabled = (c.isOccurrence || c.isException || c.isRecurring) && c.isAnyItemSelected
            addAction.label = item.select_label;
            item.cardActions.push(addAction);
        } else {
            var removeAction = Object.assign({}, c.cardActions.remove);
            removeAction.label = item.deselect_label;
            item.cardActions.push(removeAction);
        }
    }

    /**
     * Validates the items in the reservation basket and shows a message if items
     * are no longer available. Also updates the floor selector options if we're
     * currently on the map view
     * @param {string} eventType - the type of event that caused this function to be triggered
     * @private
     */
    function _validateSelection(eventType) {

        var selectedItemIds = wsdReservationBasket.getSelectedIds();
        c.isMultiItemSelection = selectedItemIds.length > 1;
        c.isAnyItemSelected = selectedItemIds.length > 0;
        c.canSubmitReservation = false;

        wsdReservationBasket.validateSelected().then(function(validation) {

            c.canSubmitReservation = true;
            c.selectedItems = validation.availableReservables;
            c.isMultiItemSelection = validation.availableReservables.length > 1;
            c.isAnyItemSelected = validation.availableReservables.length > 0;

            //On the edit flow on initial load by the time building strip watcher is triggered c.selectedItems arent populated 
            //so to ensure correct count we are constructing the building strip here
            if (c.isEditing && eventType == 'landing' && _.isEmpty(c.selectedBuildingToSearch)) {
                _constructBuildingStrip(c.selectedItems);
                c.selectedBuildingToSearch = c.searchBuildingList[0].building;
            }

            $timeout(function() {
                $scope.$apply();
            });
            // If there were exceptions, there were items removed from the selection because
            // they were no longer available or if the module changed, so selected items were cleared out
            if (validation.hasRemovedItems || wsdStateService.getState('clearedSelection')) {
                //When we change the date/time the selected spaces may not be available and are removed, so reconstructing the building strip
                _constructBuildingStrip(c.selectedItems);
                wsdStateService.setState('searchBuildingList', c.searchBuildingList); //Since count is updated need to inform wsdSearchFilter

                //In case of recurring if the selected item is unavailable, its removed  
                //Inorder to prevent other cards from being disabled we reset card actions here
                if (eventType == 'landing' && (c.isRecurring || c.isOccurrence)) {
                    c.mappedReservables.forEach(function(item) {
                        item.is_selected = wsdReservationBasket.isSelected(item.sys_id);
                        _setCardActions(item);
                    });
                }

                _showUnavailableSelectionNotification(validation);

            } else
                _showStillAvailableSelectionNotification(validation);

            if (c.activeView.type === 'map') {
                if (c.mapType == c.MAP_TYPE.MAPPEDIN && c.mappedinConfig.floorData)
                    c.mappedinConfig.floorData = _generateFloorSelectorData(c.mappedinConfig.floorData);
                else if (c.mapType == c.MAP_TYPE.INDOOR_MAPS)
                    _evaluateAndUpdateFloorDisplayValue();
            }
            _evaluateResultsContainerBottomMargin();

        }, function(err) {
            c.selectedItems = [];
            if (err) {
                throw err;
            }
        });
    }



    /**
     * Shows a message that previously selected items no longer available
     * @param {object} validation - the validation object
     * @param {Array[Reservable]} validation.removedSelectedItems - the reservables that were removed (formerly was: validation.reservableReservables)
     * @private
     */
    function _showUnavailableSelectionNotification(validation) {
        if (c.isEditing) {
            _setAvailabilityNotification(true);
            return;
        }
        var msg = '${Your search criteria has changed; some selected items are not available. The items have been deselected.}';
        c.notificationConfig = {
            msg: msg,
            type: 'alert-warning',
            icon: 'fa-exclamation-triangle'
        };
        c.showNotification = true;
    }

    /**
     * Sets the availability notification if we're in edit mode
     * @private
     */
    function _showStillAvailableSelectionNotification(validation) {
        if (c.isEditing && validation.availableReservables.length > 0)
            _setAvailabilityNotification(false);
    }

    /**
     * Constructs the building strip with count in case there are reservables selected
     * @param {array} selectedItems - list of reservables selected
     * @private
     */
    function _constructBuildingStrip(selectedItems) {
        var listOfBuildings = wsdStateService.getState('searchBuildingList');
        var buildings = [];
        listOfBuildings.forEach(function(building) {
            var buildingObj = _constructBuildingObj(building.building, selectedItems);
            buildings.push(buildingObj);
        });
        c.searchBuildingList = buildings;
    }

    /**
     * Constructs the building object with count in case there are reservables selected to be used in building strip
     * @param {array} selectedItems - list of reservables selected
     * @private
     */
    function _constructBuildingObj(building, selectedItems) {
        if (building) {
            var noOfSelectedItems = 0;
            if (selectedItems) {
                noOfSelectedItems = selectedItems.filter(function(item) {
                    return item.building.sys_id == building.value;
                }).length;
            }
            return {
                building: {
                    displayValue: building.displayValue,
                    value: building.value,
                    label: building.label,
                    campusName: building.label ? building.label.split(",")[0] : "",
                    timezone: building.timezone,
                },
                selectedCount: noOfSelectedItems,
                countLabel: _constructCountLabel(noOfSelectedItems)
            }
        }
    }

    /**
     * Constructs the count label based on number of reservables selected
     * @param {integer} selectedCount - number of reservables selected
     * @private
     */
    function _constructCountLabel(selectedCount) {
        if (selectedCount == 0)
            return '${No item selected}';
        else if (selectedCount == 1)
            return wsdUtils.formatString("{0} {1}", selectedCount, '${item selected}');
        else
            return wsdUtils.formatString("{0} {1}", selectedCount, '${items selected}');
    }

    /**
     * create window resize event listner to adapt view rendering if applicable
     * debounce after default amount of time
     */
    function _createWindowResizeEventListener() {
        window.addEventListener("resize", debounce(function(e) {
            _evaluateScheduleViewSteps();
            _evaluateResultsContainerBottomMargin();
            _showOnlyCardViewInMobileScreen()
        }));
    }

    /**
     * show card view only in case of mobile responsiveness
     */
    function _showOnlyCardViewInMobileScreen() {
        var windowWidth = wsdUtils.getWindowWidth();
        c.previousView = _.isEmpty(c.activeView) ? c.previousView : c.activeView;
        if (c.previousView.type != 'card' && windowWidth < 768) {
            var cardView = c.viewOptions.find(function(view) {
                return view.type === 'card';
            })
            if (cardView)
                c.activeView = cardView;
            else {
                _showNotification(false, '${Reservable module has no associated views, contact the application admin.}', 'alert-warning', 'fa-exclamation-triangle');
                c.activeView = {};
            }
        }
        if (!c.activeView.type && c.previousView.type && windowWidth > 768) {
            toggleViewOption(c.previousView);
            c.showNotification = false;
        }
    }

    /**
     * Clear out all the reservable filter data, usually happens when a new search is executed through the search input
     * @private
     */
    function _resetReservableFilterData() {
        wsdStateService.setState('activeReservableFilter', null);
        wsdStateService.setState('reservableFilter', null);
        c.filterCount = 0;
    }

    /**
     * Evaluate and set bottom margin for search result container.
     * @private
     */
    function _evaluateResultsContainerBottomMargin() {
        $timeout(function() {
            var drawerHeight = $('.selected-items-bar').height();
            $('.result-container-btm-margin').css('margin-bottom', drawerHeight + 25);
        })
    }

    /**
     * re-evaluate the scheduleview total step
     * @private
     */
    function _evaluateScheduleViewSteps() {
        if (c.activeView.type !== 'schedule')
            return;

        $timeout(function() {
            c.scheduleViewTotalStep = _getScheduleViewTotalSteps();
        }, 100);
    }

    /**
     * get a numeric value of possible total steps for sheduleView.
     * For smaller width of the browser window, the step will be fixe to 2 or 3. When the window's width is bigger,
     * depending on whether the filter is opened, the total step will be smaller or bigger
     * @return {number} total step
     * @private
     */
    function _getScheduleViewTotalSteps() {
        var windowWidth = wsdUtils.getWindowWidth();

        if (windowWidth <= 576)
            return 2;

        if (windowWidth <= 991)
            return 3;

        return c.showReservableFilter ? 3 : null;
    }

    /**
     * Get a list of unavailable reservables
     * @param {Reservable[]}
     * @return {Reservable[]}
     * @private
     */
    function _getUnavailableReservables(reservables) {
        if (!wsdUtils.arrayHasElement(reservables))
            return [];

        return reservables.filter(function(reservable) {
            return !reservable.is_available;
        });
    }

    /**
     * trigger next page search
     */
    function loadMore() {
        c.isFromShowMore = true;
        _triggerSearch(null, true);
    }

    /**
     * on widget destroy, deregister all watchers, and clean out state values
     */
    function destroy() {
        wsdStateService.reset();
    }

    /**
     * deboucing event
     * @param {function} func - function to be called after debouced time
     */
    function debounce(func) {
        var timer;
        return function(event) {
            if (timer)
                clearTimeout(timer);

            timer = setTimeout(func, DEFAULT_DEBOUNCE_TIME, event);
        };
    }

    /**
     * Populate the space collection for <wsd-mappedin-map>
     * if Mappedin plugin is installed
     * @param {String} selectedFloorId - floor to be preselected
     */
    function mountWsdMappedinComponent(selectedFloorId) {

        if (c.mapType !== c.MAP_TYPE.MAPPEDIN) return;
        if (c.activeView.type !== 'map') return;
        // hide "Show More" button
        c.hasMore = false;
        var searchResult = wsdStateService.getState("searchResult");
        var isFloorSelected = selectedFloorId ? true : false;
        // If user lands on the map view for first time, we default the floorId
        if (!selectedFloorId && searchResult.defaultFloorForMapView && searchResult.defaultFloorForMapView.sys_id)
            selectedFloorId = searchResult.defaultFloorForMapView.sys_id


        var filterState = wsdStateService.getState('searchRequestObj');
        var inFlightRequestId = Math.round(Math.random() * 1e10).toString();
        var filters = {
            reservation: c.mode === 'edit' ? c.reservation : null,
            building_id: filterState.building,
            reservable_module_id: filterState.reservable_module,
            shift_id: filterState.shift,
            start_at: moment(filterState.start),
            end_at: moment(filterState.end),
            capacity: filterState.capacity,
            floor_ids: filterState.floors ? filterState.floors.split(',') : [],
            area_ids: filterState.areas ? filterState.areas.split(',') : '',
            standard_services: filterState.standard_services ? filterState.standard_services.split(',') : [],
            reservable_purposes: filterState.reservable_purposes ? filterState.reservable_purposes.split(',') : [],
            request_id: inFlightRequestId,
            sort_by: filterState.sort_by,
            ignore_same_day_validation: filterState.ignore_same_day_validation
        };

        // reset the Mappedin instance and reservation data if filter constrains changed
        var hasFilterChanged = !wsdMappedinService.filterIsEqual(lastMapFilters, filters, {
            ignore: ['request_id']
        });
        if (hasFilterChanged) {
            c.mappedinConfig = {};
            c.showMap = false;
            c.wsdMappedinReservationData = null;
        } else
            c.showMap = true;

        c.missingSpaceMap = false;
        lastMapFilters = filters;
        wsdMappedinService.getAvailabilityFacets(filters).then(function(availFacets) {

            if (!availFacets.floors.length || availFacets.filters.request_id !== inFlightRequestId)
                // abort if no results or user changes filters while in flight
                return Promise.resolve([{
                    reservableUnits: [],
                    filters: {}
                }, {}, availFacets, {}]);

            //get the floors of selected items, if any
            var floorsOfSelectedItems = {};
            var floorOfSelectedItemsWithMap;
            if (!isFloorSelected) {
                c.selectedItems.forEach(function(reservable) {
                    if (!floorsOfSelectedItems.hasOwnProperty(reservable.floor.sys_id)) {
                        floorsOfSelectedItems[reservable.floor.sys_id] = 0;
                    }
                    floorsOfSelectedItems[reservable.floor.sys_id] = floorsOfSelectedItems[reservable.floor.sys_id] + 1;
                });

                if (floorsOfSelectedItems)
                    availFacets.floors.forEach(function(floor) {
                        if (floorsOfSelectedItems.hasOwnProperty(floor.sys_id) && floor.external_id && !floorOfSelectedItemsWithMap) {
                            floorOfSelectedItemsWithMap = floor;
                            return false;
                        }
                    });
            }

            // among the available floors pick the one with selected items, or the selected one or the first as default
            var selectedFloor = !isFloorSelected && floorOfSelectedItemsWithMap ? floorOfSelectedItemsWithMap : availFacets.floors.find(
                function(floor) {
                    return floor.sys_id === selectedFloorId;
                }
            ) || availFacets.floors[0];

            var floorFilter = Object.assign({},
                filters, {
                    floor_id: selectedFloor.sys_id,
                    floor_ids: null,
                    view: c.activeView.type
                }
            );

            // request availability for the selected floor
            return Promise.all([
                wsdMappedinService.getFloorAvailability(floorFilter),
                wsdMappedinService.resolveVenueFromFloor(selectedFloor.sys_id),
                Promise.resolve(availFacets),
                Promise.resolve(selectedFloor)
            ]);
        }).then(function(taskResults) {
            var reservableUnits = taskResults[0].reservableUnits;
            var mapParams = taskResults[1];
            var requestId = taskResults[2].filters.request_id;
            var availableFloors = taskResults[2].floors;
            var selectedFloor = taskResults[3];
            // user changed filters, results are stale, abort
            if (requestId !== inFlightRequestId) return Promise.resolve(null);
            // show "no results" banner
            if (!reservableUnits.length)
                c.mappedReservables = [];
            // show "no map" banner and exit function if appropriate
            c.missingSpaceMap = mapParams.source !== c.MAP_TYPE.MAPPEDIN || !mapParams.venue || !mapParams.map;
            if (c.missingSpaceMap) {
                c.showMap = false;
                $scope.$digest();
                return;
            }
            // else render the selected floor and related availability
            _getMapConfig(mapParams.venue).then(function(mapConfig) {
                var mapColors = wsdMappedinService.getColorTheme('reservation');
                // configure map based on properties
                var configFromProperties = mapConfig.dataFromApi;
                if (Object.keys(configFromProperties).length > 0) {
                    var margin = configFromProperties.marginBetweenLabels;
                    if (margin && mapConfig.labelOptions && mapConfig.labelOptions.appearance && mapConfig.labelOptions.appearance.margin)
                        mapConfig.labelOptions.appearance.margin = margin;

                    var legendLabelAndColors = configFromProperties.legendLabelAndColors;
                    if (c.wsdMappedinReservationData && c.wsdMappedinReservationData.legends && Object.keys(legendLabelAndColors).length > 0) {
                        setLegendAndColor('available', legendLabelAndColors, c.wsdMappedinReservationData.legends, mapColors);
                        setLegendAndColor('reserved', legendLabelAndColors, c.wsdMappedinReservationData.legends, mapColors);
                        setLegendAndColor('selected', legendLabelAndColors, [], mapColors);
                    }
                }

                var options = {
                    venueSlug: mapParams.venue,
                    mapId: mapParams.map,
                    floorData: _generateFloorSelectorData(availableFloors),
                    floorId: selectedFloor.sys_id,
                    colors: mapColors,
                    title: mapParams.title,
                    config: mapConfig
                };


                // apply is_selected flag and update c.wsdMappedinReservationData
                $timeout(function() {
                    c.showMap = true;
                    Object.assign(c.mappedinConfig, options);
                });

                c.floorReservables = reservableUnits.map(c.reservableMapper);
                if (c.floorReservables.length > 0)
                    _addLabelsToIconsAndConstructRsvUsersData(c.floorReservables);
                _evaluateSelectionAndUpdateFeedback({
                    origin: 'navigation'
                });
            });

        })['catch'](function(err) {
            console.warn('wsdMappedinService error', err);
            var errorMsg = '${An error has occurred while loading the map view. Please try again}';
            _showNotification(true, errorMsg, 'alert-danger', 'fa-exclamation-triangle');
        });

    }

    /**
     * Set the legend and colors that come from the system properties
     * @param {string} legendType - the type of the room, e.g. available, reserved
     * @param {Object} legendAndColorsObject - the legend and colors that come from the API that reads the system properties
     * @param {array} legendArray - the legendArray to override
     * @param {Object} colorObject - the color object to override
     */
    function setLegendAndColor(legendType, legendAndColorsObject, legendArray, colorObject) {
        if (!legendAndColorsObject[legendType])
            return;

        var legendAndColor = legendAndColorsObject[legendType];

        if (legendAndColor.text && legendArray.length > 0)
            legendArray[c.legendTypeIndex[legendType]].displayText = legendAndColor.text;

        if (legendAndColor.color && validColorString(legendAndColor.color)) {
            if (legendArray.length > 0)
                legendArray[c.legendTypeIndex[legendType]].color = legendAndColor.color;
            if (colorObject[legendType])
                colorObject[legendType] = legendAndColor.color;
        }
    }

    /**
     * Check if the colorString provided is a valid css color
     * @param {string} colorStr - Color Representation
     * @return {boolean} if its a valid css color
     **/
    function validColorString(colorStr) {
        var styleObj = new Option().style;
        styleObj.color = colorStr;
        return styleObj.color !== '';
    }

    /**
     * Get default popup config object for unreservable spaces
     * @param {Object} polygonDetails - Details of the clicked polygon - name, description, type, id.
     * @param {Object} spaceDetails - details of the space such as region, site, campus, location_type
     * @return {{popupTemplate: string, popupVariables: object}} - default popupTemplate and popupVariables
     */
    function getDefaultPopupConfig(polygonDetails, spaceDetails) {
        spaceDetails.body = [{
            id: 1,
            displayValue: '${Not reservable}'
        }]
        spaceDetails.subtitle = wsdUtils.constructLocStr(spaceDetails, ["area", "floor", "building", "campus"]);
        spaceDetails.image = null;
        return new Promise(function(resolve, reject) {
            resolve({
                popupTemplate: 'popupcard',
                popupVariables: {
                    space: spaceDetails,
                    ctrl: c
                }
            });
        });
    }

    /**
     * On click return the configuration needed to instance a popup
     * @param {string} spaceSysId - sys_id of the selected space
     * @param {Object} spaceDetails - details of the space such as region, site, campus, location_type
     * @param {Object} polygonDetails - details of the polygon such as name, description, type, id.
     * @return {{popupTemplate: string, popupVariables: object}} - popup template and scope
     */
    function onMapSpaceSelect(spaceSysId, spaceDetails, polygonDetails) {
        if (!spaceDetails)
            spaceDetails = {};

        var selectedSpace = c.floorReservables.find(function(reservable) {
            return reservable.sys_id === spaceSysId;
        });
        // use default template for unreservables
        if (!selectedSpace)
            return getDefaultPopupConfig(polygonDetails, spaceDetails);

        _setCardActions(selectedSpace);

        // populate custom template
        var extras = c.data.showReservationDetails ? selectedSpace.reservations.map(function(res) {
            return {
                label: res.requested_for.name,
                iconClass: 'fa fa-user',
                displayValue: res.requested_for.name,
                iconTooltipText: "${Reserved for}"
            };
        }) : null;
        if (extras)
            selectedSpace.metadata = extras.concat(selectedSpace.body);
        else
            selectedSpace.metadata = selectedSpace.body;

        return new Promise(function(resolve, reject) {
            resolve({
                popupTemplate: 'popupcard',
                popupVariables: {
                    space: selectedSpace,
                    extras: extras,
                    ctrl: c
                }
            });
        });
    }

    /**
     * Generate data object used by <wsd-mappedin-map>'s floor selector
     * @param {Array} - list of floors
     * @return {object} - floor options for floor list box
     */
    function _generateFloorSelectorData(floorSelectorData) {
        var selectedSpacesPerFloor = c.selectedItems.reduce(function(selectedSpaces, selectedItem) {
            var floorId = selectedItem.floor_sys_id || selectedItem.floor.sys_id;
            selectedSpaces[floorId] = (selectedSpaces[floorId] || 0) + 1;
            return selectedSpaces;
        }, {});

        var mapFloorOptions = floorSelectorData.map(function(floorOption) {
            var displayValueModifier = selectedSpacesPerFloor[floorOption.sys_id] ? " (" + selectedSpacesPerFloor[floorOption.sys_id] + ")" : "";
            // keep unmodified floor name for future updates
            if (!floorOption.hasOwnProperty('original_display_value'))
                floorOption.original_display_value = floorOption.display_value;
            return {
                sys_id: floorOption.sys_id,
                display_value: floorOption.original_display_value + displayValueModifier,
                original_display_value: floorOption.original_display_value
            };
        });

        return mapFloorOptions;
    }

    /**
     * Get map config using wsdMappedinMapConfigService. The dependency gets added if mappedin is installed.
     * @return {Promise} - Configurations which are required to initialize the map.
     */
    function _getMapConfig(venueSlug) {

        var config = {};
        if (c.mapType === c.MAP_TYPE.MAPPEDIN) {
            try {
                var injector = angular.element(document.body).injector();
                config = injector.get('wsdMappedinMapConfigService').getConfig(venueSlug);
            } catch (err) {
                console.warn('wsdMappedinMapConfigService error', err);
                var errorMsg = '${An error has occurred while loading the map. Please try again}';
                _showNotification(true, errorMsg, 'alert-danger', 'fa-exclamation-triangle');
            }
        }
        return config;
    }


    /**
     * Get map legends using wsdMapLegendService. The dependency gets added if mappedin is installed.
     * @return {Array} - Array of legends to display on map.
     */
    function _getMapLegend() {
        var legends = [];
        if (c.mapType == c.MAP_TYPE.MAPPEDIN) {
            try {
                var injector = angular.element(document.body).injector();
                legends = injector.get('wsdMapLegendService').bookingLegends;
            } catch (err) {
                console.warn('wsdMapLegendService error', err);
                var errorMsg = '${An error has occurred while loading the map. Please try again}';
                _showNotification(true, errorMsg, 'alert-danger', 'fa-exclamation-triangle');
            }
        }
        return legends;
    }


    function mountWsdIndoorMapsComponent(selectedFloorId) {
        var searchResult = wsdStateService.getState("searchResult");
        var searchFilters = wsdStateService.getState('searchRequestObj');
        if (c.activeView.type !== 'map' || c.mapType !== c.MAP_TYPE.INDOOR_MAPS || !searchFilters)
            return;
        c.hasMore = false;
        c.missingSpaceMap = false;
        c.wsdIndoorMapObject.selectedFloor = {};
        c.selectedBuilding = searchFilters.building

        // If user lands on the map view for first time, we default the floorId
        if (!selectedFloorId && searchResult.defaultFloorForMapView && searchResult.defaultFloorForMapView.sys_id)
            selectedFloorId = searchResult.defaultFloorForMapView.sys_id;

        var floorsData = wsdStateService.getState('floorsOfCurrentBuilding');

        c.wsdIndoorMapObject.floors = floorsData && Array.isArray(floorsData.floors) ? floorsData.floors.slice(0) : [];
        c.wsdIndoorMapObject.floors = c.wsdIndoorMapObject.floors.filter(function(floor) {
            return floor.external_id;
        });

        if (searchFilters.floors || searchFilters.areas || searchFilters.near_by_location_id || c.selectedItems.length) {
            c.wsdIndoorMapObject.currentMapFocusLevel = 'floor'
            if (searchFilters.floors) {
                c.wsdIndoorMapObject.floors = c.wsdIndoorMapObject.floors.filter(function(floor) {
                    return floor.sys_id === searchFilters.floors.split(',')[0];
                });
            }
        } else {
            c.wsdIndoorMapObject.currentMapFocusLevel = 'campus'
            // Stop loader if map stays at campus level
            c.wsdIndoorMapObject.isMapwizeLoading = false;
        }


        var floorsOfSelectedItems = {};
        c.selectedItems.forEach(function(reservable) {
            if (!floorsOfSelectedItems.hasOwnProperty(reservable.floor.sys_id)) {
                floorsOfSelectedItems[reservable.floor.sys_id] = 0;
            }
            floorsOfSelectedItems[reservable.floor.sys_id] = floorsOfSelectedItems[reservable.floor.sys_id] + 1;
        });

        var floorOfSelectedItemsWithMap;
        c.wsdIndoorMapObject.floors.forEach(function(floor) {
            if (floorsOfSelectedItems.hasOwnProperty(floor.sys_id) && !floorOfSelectedItemsWithMap) {
                floorOfSelectedItemsWithMap = floor;
                return false;
            }
        });

        c.wsdIndoorMapObject.selectedFloor = floorOfSelectedItemsWithMap ? floorOfSelectedItemsWithMap : c.wsdIndoorMapObject.floors.find(function(floor) {
            return floor.sys_id === selectedFloorId;
        }) || c.wsdIndoorMapObject.floors[0];

        if (!c.wsdIndoorMapObject.selectedFloor || !c.wsdIndoorMapObject.selectedFloor.external_id) {
            c.missingSpaceMap = true;
            return;
        }

        c.wsdIndoorMapObject.indoorMapParams = c.wsdIndoorMapObject.selectedFloor.indoorMapData;
        c.missingSpaceMap = !c.wsdIndoorMapObject.indoorMapParams || c.wsdIndoorMapObject.indoorMapParams.source !== c.MAP_TYPE.INDOOR_MAPS || !c.wsdIndoorMapObject.indoorMapParams.campus_external_id || !c.wsdIndoorMapObject.indoorMapParams.building_external_id;

        if (c.missingSpaceMap)
            return;

        c.wsdIndoorMapObject.selectedFloor.externalId = c.wsdIndoorMapObject.selectedFloor.external_id;
        var requiredFloorsData = c.wsdIndoorMapObject.floors.map(function(item) {
            return {
                sys_id: item.sys_id,
                externalId: item.external_id,
                displayValue: item.name,
                original_display_value: item.name
            }
        });
        if (c.wsdIndoorMapObject.currentMapFocusLevel == 'floor') {
            setFloorSelectorOptions(requiredFloorsData, c.wsdIndoorMapObject.selectedFloor.sys_id, false);
            if (c.wsdIndoorMapObject.selectedFloor && indoorMapObj && indoorMapObj.getFloor() && indoorMapObj.getFloor().sys_id == c.wsdIndoorMapObject.selectedFloor.externalId)
                getIndoorMapFloorAvailability(c.wsdIndoorMapObject.selectedFloor.sys_id);
        }
        if (!c.wsdIndoorMapObject.isInitialIndoorMapLoad)
            setInitialFocusForIndoorMap();
    }

    function getIndoorMapFloorAvailability(floorId) {
        c.wsdIndoorMapObject.isMapwizeLoading = true;
        var filterState = wsdStateService.getState('searchRequestObj');
        var inFlightRequestId = Math.round(Math.random() * 1e10).toString();
        var filters = {
            reservation: c.mode === 'edit' ? c.reservation : null,
            neighborhood: filterState.neighborhood,
            building_id: filterState.building,
            reservable_module_id: filterState.reservable_module,
            shift_id: filterState.shift,
            start_at: moment(filterState.start),
            end_at: moment(filterState.end),
            capacity: filterState.capacity,
            floor_ids: filterState.floors ? filterState.floors.split(',') : [],
            area_ids: filterState.areas ? filterState.areas.split(',') : '',
            standard_services: filterState.standard_services ? filterState.standard_services.split(',') : [],
            reservable_purposes: filterState.reservable_purposes ? filterState.reservable_purposes.split(',') : [],
            request_id: inFlightRequestId,
            sort_by: filterState.sort_by,
            near_by_location_id: filterState.near_by_location_id,
            view: filterState.view,
            timezone: filterState.timezone,
            ignore_same_day_validation: filterState.ignore_same_day_validation
        };

        var floorFilter = Object.assign({},
            filters, {
                floor_id: floorId,
                floor_ids: null,
                view: c.activeView.type
            }
        );

        // Retrieve space for current floor/neighborhood and store it in c.wsdIndoorMapObject.neighborhoodSpaces
        var neighborhoodPromise = Promise.resolve(null);
        if (filterState.neighborhood) {
            neighborhoodPromise = wsdIndoorMapService.getSpacesExternalIdsForFloorAndNeighborhood(floorId, filterState.neighborhood)['catch'](function(err) {
                console.error('getSpacesExternalIdsForFloorAndNeighborhood error', err);
                return null; // Return to avoid unnecessary mapload error
            });
        }

        Promise.all([
                wsdMappedinService.getFloorAvailability(floorFilter),
                neighborhoodPromise
            ])
            .then(function(results) {
                var reservableUnits = results[0].reservableUnits;
                c.floorReservables = reservableUnits.map(c.reservableMapper);
                if (c.floorReservables.length > 0)
                    _addLabelsToIconsAndConstructRsvUsersData(c.floorReservables);

                if (results[1]) {
                    c.wsdIndoorMapObject.neighborhoodSpaces = results[1].reduce(function(acc, curr) {
                        acc[curr] = true;
                        return acc;
                    }, {});
                } else {
                    c.wsdIndoorMapObject.neighborhoodSpaces = {};
                }

                wsdIndoorMapService.getIndoorMapConfig(c.wsdIndoorMapObject.indoorMapParams.building_external_id).then(function(response) {
                    c.indoorMaplegendArray = [];
                    // configure map based on properties
                    var mapConfig = response.mapConfig;
                    c.indoorMapSpaceDecoration = response.indoorMapSpaceDecoration;
                    // check pattern availibility on init
                    checkPatternAvailability(c.patternEnabled);

                    _evaluateSelectionAndUpdateFeedback({
                        origin: 'navigation'
                    });
                    applyStyle();
                    $timeout(function() {
                        if (indoorMapObj && wsdStateService.getState('reservationPath') === BROWSE_NEAR_A_PERSON) {
                            var nearByUserReservedLocExt = wsdStateService.getState('selectedUserReservedLoc').externalId;
                            if (nearByUserReservedLocExt != 'undefined')
                                addNearbyUserMarker(nearByUserReservedLocExt);
                        } else if (indoorMapObj && wsdStateService.getState('reservationPath') != BROWSE_NEAR_A_PERSON)
                            removeIndoorMapMarker();

                        if (Object.keys(mapConfig).length > 0) {
                            var legendLabelAndColors = mapConfig.legendLabelAndColors;

                            if (c.wsdIndoorMapAvailabilityData && Object.keys(legendLabelAndColors).length > 0) {
                                var availabilityArray = JSON.parse(c.wsdIndoorMapAvailabilityData._crc);
                                c.indoorMaplegendArray = [];
                                indoorMapObj.registerImage('available-room-pattern', c.indoorMapSpaceDecoration.available.pattern);
                                indoorMapObj.registerImage('booked-room-pattern', c.indoorMapSpaceDecoration.reserved.pattern);
                                setLegendAndColorForIndoorMaps('available', legendLabelAndColors, availabilityArray[0], c.indoorMapSpaceDecoration);
                                setLegendAndColorForIndoorMaps('reserved', legendLabelAndColors, availabilityArray[1], c.indoorMapSpaceDecoration);
                                setIndoorMapLegends(c.indoorMaplegendArray);
                                c.wsdIndoorMapObject.isMapwizeLoading = false;
                            }
                        }
                    });
                });
            })['catch'](function(err) {
                c.wsdIndoorMapObject.isMapwizeLoading = false;
                console.warn('wsdMappedinService.getFloorAvailability error', err);
                var errorMsg = '${An error has occurred while loading reservable spaces for map view. Please try again}';
                _showNotification(true, errorMsg, 'alert-danger', 'fa-exclamation-triangle');
            });
    }

    function setIndoorMapLegends(legendArray) {
        c.legends = legendArray;
    }

    function setInitialFocusForIndoorMap() {
        if (c.wsdIndoorMapObject.currentMapFocusLevel === 'floor') {
            centerOnFloor(c.wsdIndoorMapObject.selectedFloor.externalId);
        } else if (c.wsdIndoorMapObject.currentMapFocusLevel === 'campus') {
            if (!c.wsdIndoorMapObject.isInitialIndoorMapLoad && indoorMapObj) {
                removeIndoorMapMarker();
                addBuildingMarker();
            }

            if (!indoorMapObj) {
                return;
            }

            var requiredFloorsData = c.wsdIndoorMapObject.floors.map(function(item) {
                return {
                    sys_id: item.sys_id,
                    externalId: item.external_id,
                    displayValue: item.name,
                    original_display_value: item.name,
                };
            });

            setFloorSelectorOptions(requiredFloorsData, c.wsdIndoorMapObject.selectedfloor)
            centerOnFloor(c.floorSelectorOptions.value.externalId)

            if (indoorMapObj.getFloor() && indoorMapObj.getFloor().sys_id == c.floorSelectorOptions.value.externalId) {
                onFloorRendered({
                    sys_id: c.floorSelectorOptions.value.externalId
                });
            }
        }
    }

    function toggleBuildingSelectorPicker(shouldShowBuilding) {
        if (c.buildingSelectorOptions)
            c.buildingSelectorOptions.shouldShow = shouldShowBuilding;
    }

    function toggleFloorSelectorPicker(shouldShowFloor) {
        if (c.floorSelectorOptions)
            c.floorSelectorOptions.shouldShow = shouldShowFloor;
    }


    /**
     * On campus Enter - Load the campus in map with building selector
     * @param {Object} campus
     */
    function onCampusEnter(campus) {
        c.currentCampusExtId = campus.sys_id;
        setBuildingSelectorOptions(c.data.mapCampusExternalIdToBuildings[c.currentCampusExtId]);
        toggleBuildingSelectorPicker(true);
        toggleFloorSelectorPicker(false);
        c.wsdIndoorMapObject.addBuildingMarker = true;
        addBuildingMarker();
    }


    /**
     * On campus exit - remove selected building marker, hide floor and building selectors.
     * @param {Object} campus
     */
    function onCampusExit(campus) {
        toggleBuildingSelectorPicker(false);
        toggleFloorSelectorPicker(false);
        c.wsdIndoorMapObject.addBuildingMarker = false;
        removeIndoorMapMarker();
    }

    /**
     * On building Enter - Load the selected floor or default floor in map with floor selector
     * hide the building selector
     * Show legends based on availabilty.
     * @param {Object} building
     */
    function onBuildingEnter(building) {
        c.wsdIndoorMapObject.addBuildingMarker = false;
        removeIndoorMapMarker();
        c.currentBuildingExtId = building.sys_id;
        toggleBuildingSelectorPicker(false);
        if (c.wsdIndoorMapObject.selectedFloor && c.wsdIndoorMapObject.indoorMapParams && c.wsdIndoorMapObject.indoorMapParams.building_external_id === c.currentBuildingExtId) {
            var requiredFloorsData = c.wsdIndoorMapObject.floors.map(function(item) {
                return {
                    sys_id: item.sys_id,
                    externalId: item.external_id,
                    displayValue: item.name,
                    original_display_value: item.name,
                }
            });
            setFloorSelectorOptions(requiredFloorsData, c.wsdIndoorMapObject.selectedFloor.sys_id, true);
            $scope.$evalAsync();
        } else {
            getFloors(c.currentBuildingExtId).then(function(data) {
                setFloorSelectorOptions(data, c.wsdIndoorMapObject.selectedFloor.sys_id, true);
                $scope.$evalAsync();
            });
        }
    }

    /**
     * On building exit - Load the campus in map with building selector and campus buildings
     * hide the floor selector
     * @param {Object} building
     */
    function onBuildingExit(building) {
        setBuildingSelectorOptions(c.data.mapCampusExternalIdToBuildings[c.currentCampusExtId]);
        toggleBuildingSelectorPicker(true);
        toggleFloorSelectorPicker(false);
        setIndoorMapLegends(undefined);
        c.wsdIndoorMapObject.addBuildingMarker = true;
        addBuildingMarker();
        $scope.$evalAsync();
    }

    /**
     * Reset indoor map card data
     */
    function resetIndoorMapCardData(value) {
        c.cardData = value;
    }

    /**
     * Set the legend and colors that come from the system properties
     * @param {string} legendType - the type of the room, e.g. available, reserved
     * @param {Object} legendAndColorsObject - the legend and colors that come from the API that reads the system properties
     * @param {Number} number - Availability count.
     * @param {Object} mapColor - the color object to override
     */
    function setLegendAndColorForIndoorMaps(legendType, legendAndColorsObject, number, mapColor) {
        if (!legendAndColorsObject[legendType])
            return;
        c.indoorMaplegendArray.push({
            displayText: Number.isInteger(number) ? legendAndColorsObject[legendType].text + " (" + number + ")" : legendAndColorsObject[legendType].text,
            color: mapColor[legendType].fill_color,
            pattern: mapColor[legendType].pattern,
            icon: mapColor[legendType].icon_name === 'available-room' ? 'green_dot.svg' : 'red_dot.svg'
        });
    }

    function onCardClose() {
        c.cardData = undefined;
    }

    /**
     * Get the new value for pattern usage when the user toggle on/off patterns on the map and update user preference
     * @param {booelan} newValue 
     */
    function onPatternEnabledChange(newValue) {
        checkPatternAvailability(newValue);
        spUtil.setPreference('wsd_indoor_mapping_pattern', newValue);
        $timeout(applyStyle, 0);
    }

    /**
     * 
     * @param {*} patternEnabled 
     * @param {*} indoorMapSpaceDecoration 
     */
    function checkPatternAvailability(patternEnabled) {
        if (patternEnabled && !c.indoorMapSpaceDecoration.available.pattern)
            spUtil.addErrorMessage('${No pattern configured for available spaces. Please contact an administrator.}');

        if (patternEnabled && !c.indoorMapSpaceDecoration.reserved.pattern)
            spUtil.addErrorMessage('${No pattern configured for booked spaces. Please contact an administrator.}');
    }

    /**
     * Handling indoor map events 
     */
    function onMapEvent(event) {
        switch (event.name) {
            case 'click':
                onMapClick(event.arguments);
                break;
            case 'campusenter':
                onCampusEnter(event.arguments);
                break;
            case 'campusexit':
                onCampusExit(event.arguments);
                break;
            case 'buildingenter':
                onBuildingEnter(event.arguments);
                break;
            case 'buildingexit':
                onBuildingExit(event.arguments);
                break;
            case 'floorloading':
                onFloorRendered(event.arguments);
                break;

        }
    }

    function onFloorRendered(event) {
        if (event) {
            if (c.wsdIndoorMapObject.indoorMapParams && isSameBuildingAsSearchFilter(c.wsdIndoorMapObject.indoorMapParams.building_external_id, indoorMapObj.getBuilding().sys_id)) {
                var selectedFloor = c.floorSelectorOptions.values.find(function(floor) {
                    return floor.externalId == event.sys_id;
                });
                c.floorSelectorOptions.value = selectedFloor;
                c.wsdIndoorMapObject.selectedFloor = selectedFloor;
                getIndoorMapFloorAvailability(selectedFloor.sys_id);
            }
        }
    }

    /**
     * On map click - call appropriate methods.
     * @param {Object} event
     */
    function onMapClick(event) {
        if (event.campus)
            onIndoorMapCampusClick(event);
        else if (event.building)
            onIndoorMapBuildingClick(event)
        else if (event.place)
            onIndoorMapPlaceClick(event)
    }

    /**
     * On campus click - center on campus
     * @param {Object} event
     */
    function onIndoorMapCampusClick(event) {
        centerOnCampus(event.campus.sys_id);
    }

    /**
     * On building click - center on building
     * @param {Object} event
     */
    function onIndoorMapBuildingClick(event) {
        indoorMapObj.getCameraForBuilding(event.building.sys_id, function(err, camera) {
            delete camera.center.floor
            if (c.wsdIndoorMapObject.selectedFloor)
                camera.center.floor = {
                    sys_id: c.wsdIndoorMapObject.selectedFloor.externalId
                };
            indoorMapObj.centerOn(camera)
        })
    }

    function addNearbyUserMarker(placeExternalId) {
        removeIndoorMapMarker()
        indoorMapObj.addMarkerOnPlace(placeExternalId, buildUserMarker());
    }

    function buildUserMarker() {
        var div = document.createElement('div');
        div.className = "indoor-map-nearby-user-marker";
        var nearByUserState = wsdStateService.getState('nearbyUser');
        var userDetails = nearByUserState.hasOwnProperty('userDetails') ? nearByUserState.userDetails : nearByUserState;
        if (userDetails.avatar) {
            var img = document.createElement("img");
            img.src = userDetails.avatar;
            div.appendChild(img);
        } else if (userDetails.initials) {
            var initialTag = document.createElement("div");
            initialTag.className = "indoor-map-nearby-user-initials_class";
            initialTag.innerHTML = userDetails.initials;
            div.appendChild(initialTag);
        }
        var marker = new indoormap.Marker({
            anchor: 'bottom',
            element: div,
        });
        return marker;
    }

    /**
     * On place click - center on place, Open appropriate card and calculate availability score if chosen.
     * Space will be highlighted
     * @param {Object} event
     */
    function onIndoorMapPlaceClick(event) {
        var selectedSpace = c.floorReservables.find(function(reservable) {
            return reservable.external_id === event.place.sys_id;
        });
        var reservableType = wsdStateService.getState('selectedReservableModule').reservable_type;
        var recurringScoreEnabled = c.data.enable_recurring_score;
        var recurringPattern = wsdStateService.getState('recurringPattern');
        var reservableQuantityMap = {};
        reservableQuantityMap[selectedSpace.sys_id] = selectedSpace.reservable_quantity;

        if (selectedSpace && recurringPattern && recurringScoreEnabled) {
            c.server.get({
                action: 'getAvailabilityScoreOfSelectedLocation',
                reservableType: reservableType,
                spaces: [selectedSpace.sys_id],
                recurringPattern: recurringPattern,
                reservableQuantityMap: reservableQuantityMap,
                enable_allocation_duration_check: wsdStateService.getState('selectedReservableModule').enable_allocation_duration_check
            }).then(function(response) {
                validateClickAndLoadCard(event);
                var availabilityScoreDisplayInfo = getAvailabilityScoreDisplayInfoForSpace(response.data.availabilityScore[selectedSpace.sys_id]);
                c.cardData.metaData = c.cardData.metaData.concat(availabilityScoreDisplayInfo);
            })
        } else
            validateClickAndLoadCard(event);

    }

    /**
     * On place click - get availability score info object containing icon style.
     * @param {Object} score
     */
    function getAvailabilityScoreDisplayInfoForSpace(score) {
        var obj = {
            id: "availability_score",
            label: "Availability Score",
            iconClass: 'fa-user',
            displayValue: 'placeholder'
        };
        if (score) {
            obj.displayValue = score.score + " " + wsdUtils.formatString(c.data.translations.availabilityScoreMessage);
            if (score.availability == "full") {
                obj.iconClass = "fa fa-check-circle";
                obj.iconColor = "#3B7F00";
            } else if (score.availability == "normal") {
                obj.iconClass = "fa fa-circle-o";
                obj.iconColor = "#3B7F00";
            } else if (score.availability == "partial") {
                obj.iconClass = "fa fa-adjust";
                obj.iconColor = "#6E6F78";
            } else if (score.availability == "limited") {
                obj.iconClass = "fa fa-circle";
                obj.iconColor = "#CC293C";
            } else if (score.availability == "zero") {
                obj.iconClass = "fa fa-ban";
                obj.iconColor = "#CC293C";
            }
        }
        return obj;
    }

    /**
     * On place click - center on place, Open appropriate card.
     * Space will be highlighted
     * @param {Object} event
     */
    function validateClickAndLoadCard(event) {
        var selectedSpace = c.floorReservables.find(function(reservable) {
            return reservable.external_id === event.place.sys_id;
        });
        if (!selectedSpace)
            resetIndoorMapCardData(undefined);
        else {
            centerOnPlace(event.place.sys_id);
            var availability = "unavailable";
            if (c.wsdIndoorMapAvailabilityData.availableExternalIds.has(event.place.sys_id))
                availability = "available";
            else if (c.wsdIndoorMapAvailabilityData.reservedExternalIds.hasOwnProperty(event.place.sys_id))
                availability = "reserved";

            if (!selectedSpace) {
                selectedSpace = {
                    external_id: event.place.sys_id,
                    name: event.place.title,
                    subtitle: "${Not Reservable}"
                }
            }
            //Check if space is selected
            var selectedIds = wsdReservationBasket.getSelectedIds();
            var index = selectedIds.indexOf(selectedSpace.sys_id);
            if (index > -1)
                availability = "selected";
            c.cardData = getFormattedCardData(selectedSpace, availability);
        }
        $timeout(function() {
            applyStyle();
        })
    }

    /**
     * Return the formatted cardData object.
     * @param {Object} spaceDetailsObj
     * @param {String} availability = {available, reserved, unavailable, selected}
     */
    function getFormattedCardData(spaceDetailsObj, availability) {
        var extras = c.data.showReservationDetails && spaceDetailsObj.reservations ? spaceDetailsObj.reservations.map(function(res) {
            return {
                id: "1000",
                label: res.requested_for.name,
                iconClass: 'fa-user',
                displayValue: res.requested_for.name
            };
        }) : [];
        //get the card actions for the current reservable object
        _setCardActions(spaceDetailsObj);
        var applicableAction = spaceDetailsObj.cardActions;

        var metaData = extras;
        if (spaceDetailsObj.body && spaceDetailsObj.body.length > 0)
            metaData = metaData.concat(spaceDetailsObj.body);

        var favoriteObj = spaceDetailsObj.favorite ? {
            sys_id: spaceDetailsObj.favorite.sys_id,
            tableName: spaceDetailsObj.favorite.tableName,
            shouldNotOverrideFavoriteEvaluation: true
        } : null;
        spaceDetailsObj.tags = spaceDetailsObj.tags ? spaceDetailsObj.tags : [];
        setApplicableTagsForCard(spaceDetailsObj.tags, availability);

        var cardData = {
            sysId: spaceDetailsObj.sys_id,
            externalId: spaceDetailsObj.external_id,
            title: spaceDetailsObj.name,
            favorite: favoriteObj,
            identifiers: spaceDetailsObj.tags,
            subtitle: spaceDetailsObj.subtitle,
            image: spaceDetailsObj.image,
            actions: applicableAction,
            metaData: metaData,
            extraData: spaceDetailsObj,
            actionsCallback: c.cardActionsCallback,
            onCardClose: c.onCardClose
        };
        return cardData;
    }

    function setApplicableTagsForCard(tags, availability) {
        availability = (availability == "selected") ? "available" : availability;
        if (!(tags.find(function(tag) {
                return tag.value == availability;
            }))) {
            if (availability == 'available' || availability == 'selected') {
                tags.push({
                    displayValue: "${Available}",
                    tagClass: "available-space-tag",
                    label: "${Available space}",
                    value: "available"
                });
            } else if (availability == 'reserved') {
                tags.push({
                    displayValue: "${Booked}",
                    tagClass: "booked-space-tag",
                    label: "${Booked space}",
                    value: "reserved"
                });
            }
        }
    }

    /**
     * Extracting the reservedUserName from the reservationsForAllUsers Data. 
     * @param {Object} reservationsForAllUsers Object which contains all the data about reserved spaces. 
     */

    function updateReservationNames(reservationsForAllUsers) {
        reservationsForAllUsers.forEach(function(reservationInfo) {
            var externalId = reservationInfo.external_id;
            var userName = reservationInfo.reserved_user_name;

            if (!externalId || !userName)
                return;
            if (c.placeStyles[externalId]) {
                c.placeStyles[externalId].reservation_user_name = userName;
            } else {
                c.placeStyles[externalId] = {
                    "reservation_user_name": userName
                };
            }
        });
    }

    /**
     * Apply appropriate styeling to map based on availability.
     * @param {String} indoor map place sys_id or wsd space external id
     * @param {Object} applicableStyle object
     */


    function applyStyle(spaceExternalId, applicableStyle) {
        if (spaceExternalId)
            c.wsdIndoorMapAvailabilityData.spaceDecoration[spaceExternalId] = applicableStyle;
        var styles = c.wsdIndoorMapAvailabilityData.spaceDecoration || {};
        if (indoorMapObj) {
            if (spaceExternalId) {
                $timeout(function() {
                    if (c.placeStyles.hasOwnProperty(spaceExternalId)) {
                        c.placeStyles[spaceExternalId] = handlePatternStyle(spaceExternalId, styles[spaceExternalId], c.patternEnabled);
                        updateReservationNames(reservationData);
                    } else {
                        c.placeStyles = {
                            spaceExternalId: handlePatternStyle(spaceExternalId, styles[spaceExternalId], c.patternEnabled)
                        };
                        updateReservationNames(reservationData);
                    }
                });
            } else {
                $timeout(function() {
                    c.placeStyles = handlePatternStyles(styles, c.patternEnabled);
                    updateReservationNames(reservationData);
                });
            }
        }
    }



    /**
     * generate a spaceDecoration style object based on pattern user preference 
     * @param {object} styles 
     * @param {boolean} patternEnabled
     * @returns 
     */
    function handlePatternStyles(styles, patternEnabled) {
        var newStyles = {};

        for (var key in styles) {
            newStyles[key] = handlePatternStyle(key, styles[key], patternEnabled);
        }

        for (var key2 in c.wsdIndoorMapObject.neighborhoodSpaces) {
            if (!newStyles[key2]) {
                newStyles[key2] = handlePatternStyle(key2, styles[key2] || {}, patternEnabled);
            }
        }

        return newStyles;
    }

    function handlePatternStyle(spaceExternalId, style, patternEnabled) {
        var newStyle = {};

        newStyle = {
            hover_fill_color: style.hover_fill_color,
            hover_fill_opacity: style.hover_fill_opacity,
            icon_name: style.icon_name,
            order: style.order,
            stroke_color: style.stroke_color
        };

        if (patternEnabled) {
            newStyle.pattern = style.pattern;
            newStyle.fill_pattern = style.fill_pattern;
            newStyle.fill_opacity = 0;
            newStyle.stroke_width = 1;
            newStyle.stroke_color = '#8790A1';
        } else {
            newStyle.fill_color = style.fill_color;
            newStyle.fill_opacity = style.fill_opacity;
        }

        if (c.wsdIndoorMapObject.neighborhoodSpaces[spaceExternalId]) {
            newStyle.stroke_width = 2;
            newStyle.stroke_color = '#4F52BD';
        }

        return newStyle;
    }

    /**
     * Add building marker if search criteria building is available in loaded campus.
     */
    function addBuildingMarker() {
        addIndoorMapMarker(c.wsdIndoorMapObject.indoorMapParams.building_external_id);
    }

    /**
     * Add indoor map marker to the location.
     * @param {String} externalId
     */
    function addIndoorMapMarker(externalId) {
        indoorMapObj.getCameraForBuilding(externalId, function(err, camera) {
            if (err) {
                return;
            }
            if (c.wsdIndoorMapObject.addBuildingMarker) {
                delete camera.center.floor;
                var marker = indoorMapObj.addMarker(camera.center);
                marker._element.onclick = function(e) {
                    centerOnBuilding(c.wsdIndoorMapObject.indoorMapParams.building_external_id);
                    e.stopPropagation();
                };
            }
        })
    }

    /**
     * Remove indoor map markers
     */
    function removeIndoorMapMarker() {
        indoorMapObj.removeMarkers();
    }

    function isSameBuildingAsSearchFilter(searchFilterBuildingExt, mapBuildingExt) {
        return searchFilterBuildingExt == mapBuildingExt;
    }

    /**
     * Get the lost of floors under the building
     * @param {String} building
     * @return {Object} - list of building details object
     */
    function onBuildingSelectorChange(building) {
        toggleBuildingSelectorPicker();
    }

    /**
     * Get list of reservable indoor map floors in sorted(with name) order
     * @param {String} buildingSysId
     * @return {Object} - list of floor details object
     */
    function getFloors(buildingSysId) {
        return new Promise(function(resolve, reject) {
            var encodedQuery = "active=true^is_reservable=true^building.external_idSTARTSWITH" + buildingSysId + "^wsd_source=indoor_maps^ORDERBYorder^ORDERBYname";
            var fields = "sys_id,external_id,name,title";
            var table = "sn_wsd_core_floor";
            var url = generateQueryUrl({
                table: table,
                encodedQuery: encodedQuery,
                fields: fields
            })
            return $http({
                url: url,
                method: 'GET'
            }).then(function(response) {
                var result = response.data.result.map(function(item) {
                    return {
                        sys_id: item.sys_id,
                        externalId: item.external_id,
                        displayValue: item.title,
                        original_display_value: item.title
                    }
                });
                return resolve(result);
            })
        });
    }

    /**
     * center map on indoor map campus
     * @param {String} externalId
     */
    function centerOnCampus(externalId) {
        c.addZoom = true;
        indoorMapObj.getCameraForCampus(externalId, centerOnCamera);
    }

    /**
     * center map on indoor map building
     * @param {String} externalId
     */
    function centerOnBuilding(externalId) {
        c.addZoom = false;
        indoorMapObj.getCameraForBuilding(externalId, centerOnCamera);
    }

    /**
     * center map on indoor map floor
     * @param {String} externalId
     */
    function centerOnFloor(externalId) {
        indoorMapObj.getCameraForFloor(externalId, centerOnCamera);
    }

    /**
     * center map on indoor map place
     * @param {String} externalId
     */
    function centerOnPlace(externalId) {
        indoorMapObj.getCameraForPlace(externalId, function(err, camera) {
            delete camera.zoom;
            delete camera.pitch;
            delete camera.bearing;
            indoorMapObj.centerOn(camera);
        });
    }

    /**
     * center map based on indoor map camera object.
     * @param {err} Error obj
     * @param {camera} Camera object 
     */
    function centerOnCamera(err, camera) {
        if (err) {
            console.error(err);
            return;
        }
        indoorMapObj.centerOn(camera);
    }

    /**
     * Set floor selector options for indoor map
     * @param {Array} data - A list of building objects.
     * @param {String} selectedValue - sys id of selected floor
     */
    function setFloorSelectorOptions(data, selectedValue, ignoreAvailabilityCall) {
        var selectedFloor = data.find(
            function(floor) {
                return floor.sys_id === selectedValue;
            }
        ) || data[0];

        var floorsOfSelectedItems = {};
        c.selectedItems.forEach(function(item) {
            if (!floorsOfSelectedItems.hasOwnProperty(item.floor.sys_id))
                floorsOfSelectedItems[item.floor.sys_id] = 0;
            floorsOfSelectedItems[item.floor.sys_id] = floorsOfSelectedItems[item.floor.sys_id] + 1;
        });
        data.forEach(function(item) {
            if (floorsOfSelectedItems.hasOwnProperty(item.sys_id))
                item.displayValue = item.original_display_value + " (" + floorsOfSelectedItems[item.sys_id] + ")";
            else
                item.displayValue = item.original_display_value;
        });

        c.floorSelectorOptions = {
            shouldShow: true,
            placeholder: "${Select a floor}",
            values: data,
            value: selectedFloor
        }
    }

    function _evaluateAndUpdateFloorDisplayValue() {
        if (c.floorSelectorOptions && c.floorSelectorOptions.shouldShow)
            setFloorSelectorOptions(c.floorSelectorOptions.values, c.floorSelectorOptions.value.sys_id, true);
    }

    /**
     * Set building selector options for indoor map
     * @param {Array} data - A list of building objects.
     */
    function setBuildingSelectorOptions(data) {
        c.buildingSelectorOptions = {
            shouldShow: false,
            placeholder: "${Select a building}",
            values: data,
        };
    }

    /**
     * Return Url string
     * @param {Object} queryObject - contains tablename, encoded query and comma seperated fields name.
     * @retrun {String} - url
     */
    function generateQueryUrl(queryObject) {
        var url = '/api/now/table/';
        url += queryObject["table"];
        url = url + '?sysparm_query=' + queryObject["encodedQuery"];
        url = url + '&sysparm_fields=' + queryObject["fields"];
        return url;
    }

    function _watchBackdropClick() {
        $('.custom-backdrop').on('click', function() {
            c.showAllSelectedReservables = false;
            $scope.$apply();
        });
    }

    /**
     * Logs appsee event
     * @param {String} eventName - Name of Appsee event.
     * @param {Object} payloadData - Additional data for appsee event
     */
    function createAppseeEvent(eventName, payloadData) {
        var payload = {};
        payload.name = eventName;
        if (payloadData)
            payload.data = payloadData;
        else
            payload.data = {};
        snAnalytics.addEvent(payload);
    }
}
/**
 * @typedef Reservable - (copy from server's reponse object)
 * @property {number} capacity - Capacity of the reservable.
 * @property {number} number_of_attendees - Amount of attendees.
 * @property {string} sys_id - Sys_id of the reservable.
 * @property {string} name - Name of the reservable.
 * @property {string} description - Description of the reservable.
 * @property {string} display_value - Display value of the reservable
 * @property {ReferenceField || null} area - Area of the reservable.
 * @property {ReferenceField || null} building - Building of the reservable.
 * @property {ReferenceField || null} campus - Campus of the reservable.
 * @property {ReferenceField || null} floor - Floor of the reservable.
 * @property {ReferenceField || null} region - Region of the reservable.
 * @property {ReferenceField || null} site - Site of the reservable.
 * @property {StandardService[]} standard_services - List of standard services of the reservable.
 */

/**
 * @typedef SortByOption
 * @property {string} id - value of the select option
 * @property {string} text - text to display in the select option
 * @property {string} icon - icon to display next to the text in the select option
 */

/**
 * Represents details about the event that caused a change to the basket
 * (e.g. appending, removing, toggling, etc.)
 * @typedef {object} EventDetails
 * @property {string} origin - the "source" of the event
 *
 * Origin can be...
 *   'interactive': user explicitly selected or deselected a reservable
 *   'landing': user landed on the page (e.g. when editing an existing reservation), and when reservable changes
 *   'validation': a filter change caused a deselection (item is no longer available)
 * - 'navigation': user navigated to new "page" of data (e.g. switching floors in the map)
 */

/** WSD Search client  */





function onSubmit() {
   var currentDate = new Date();
   var nextThursday = getNextThursday(currentDate);
 
   // Get the start date from the form
   var startDate = g_form.getValue('start_date');
   var startDateObj = new Date(startDate);
 
   // Check if the start date is before the next Thursday
   if (startDateObj < nextThursday) {
       g_form.setValue('start_date', formatDateTime(nextThursday)); // Set to next Thursday with local time
       g_form.showFieldMsg('start_date', 'Start date must be on or after the Thursday following a 6-day lead time.', 'error');
       return false; // Prevent form submission
   }

   return true; // Allow form submission if the date is valid
}

// Function to get the next Thursday date after a 6-day lead time
function getNextThursday(date) {
   var leadTime = 7; // 7-day lead time
   var leadDate = new Date(date);
   leadDate.setDate(date.getDate() + leadTime);

   var dayOfWeek = leadDate.getDay();
   var daysUntilThursday = (4 - dayOfWeek + 7) % 7; // 4 is Thursday (0 is Sunday)
   if (daysUntilThursday === 0) {
       daysUntilThursday = 7; // If today is Thursday, get the next Thursday
   }
   var nextThursday = new Date(leadDate);
   nextThursday.setDate(leadDate.getDate() + daysUntilThursday);
   nextThursday.setHours(0, 0, 0, 0); // Set time to midnight
   return nextThursday;
}

// Function to format date and time in local time zone
function formatDateTime(date) {
   var year = date.getFullYear();
   var month = ('0' + (date.getMonth() + 1)).slice(-2); // Months are zero-based
   var day = ('0' + date.getDate()).slice(-2);
   var hours = '00';
   var minutes = '00';
   var seconds = '00';
   return year + '-' + month + '-' + day + ' ' + hours + ':' + minutes + ':' + seconds + ' AM';
}

var gr = new GlideRecord('sys_user_grmember');
gr.query();

var recordsToDelete = [];

while (gr.next()) {
  var userGR = new GlideRecord('sys_user');
  if (!userGR.get(gr.user)) {
    gs.log('Marking invalid sys_id for deletion in group membership for user: ' + gr.user + ' for group: ' + gr.group.name);
    recordsToDelete.push(gr.sys_id.toString());
  } else {
    gs.log('This record is OK for user: ' + gr.user + ' in group: ' + gr.group.name);
  }
}

// Delete the marked records
for (var i = 0; i < recordsToDelete.length; i++) {
  var deleteGR = new GlideRecord('sys_user_grmember');
  if (deleteGR.get(recordsToDelete[i])) {
    deleteGR.deleteRecord();
    gs.log('Deleted record with sys_id: ' + recordsToDelete[i]);
  }
}

// Get the 'requested_for' field from the 'request_item' table
var requestedFor = current.request_item.requested_for;

// Get the first name and last name of the 'requested_for' user
var userGR = new GlideRecord('sys_user');
if (userGR.get(requestedFor)) {
    var firstName = userGR.getValue('first_name');
    var lastName = userGR.getValue('last_name');
    
    // Format the name as "First Name, First Initial of Last Name"
    var formattedName = firstName + ', ' + lastName.charAt(0) + '.';
    
    // Update the work notes with the formatted name
    current.work_notes = current.getDisplayValue('assigned_to') + ' for ' + formattedName + ' - ' + current.number;
}
function onCellEdit(sysIDs, table, oldValues, newValue, callback) {
	
	// Iterate through the oldValues array to check if the new value is different from any old value
	if (newValue != oldValues[0])
	{
		var conf = confirm("Assignment Group has been changed! This action will clear the 'Assigned To' fields for updated records. Proceed?");
		if (conf)
		{
			var gr = new GlideRecord(table);
			gr.addQuery('sys_id', 'IN', sysIDs.join(','));
			gr.query();
			while (gr.next()) 
			{
				gr.setValue('assigned_to', '');
				gr.update();
			}			
		}		
	}
  
	// Execute the callback function to complete the onCellEdit action
	callback(conf);
}

(function executeRule(current, previous /*null when async*/) {
    // Function to get the next Thursday date
    function getNextThursday(date) {
        var dayOfWeek = date.getDay();
        var daysUntilThursday = (4 - dayOfWeek + 7) % 7; // 4 is Thursday (0 is Sunday)
        if (daysUntilThursday === 0) {
            daysUntilThursday = 7; // If today is Thursday, get the next Thursday
        }
        var nextThursday = new Date(date);
        nextThursday.setDate(date.getDate() + daysUntilThursday);
        return nextThursday;
    }

    // Get the current date and the next Thursday date
    var currentDate = new Date();
    var nextThursday = getNextThursday(currentDate);

    // Get the start date from the form
    var startDate = g_form.getValue('start_date');
    var startDateObj = new Date(startDate);

    // Check if the start date is before the next Thursday
    if (startDateObj < nextThursday) {
        g_form.showFieldMsg('start_date', 'Start date must be on or after the next Thursday.', 'error');
        g_form.setValue('start_date', nextThursday.toISOString().split('T')[0]); // Set to next Thursday
    }
})(current, previous);


(function() {
    var fieldName = 'group'; // The name of the field you want to change
    var tableName = 'sys_user_grmember'; // The name of the table

    // Get the dictionary entry for the field
    var gr = new GlideRecord('sys_dictionary');
    gr.addQuery('name', tableName);
    gr.addQuery('element', fieldName);
    gr.query();

    if (gr.next()) {
        gr.internal_type = 'reference'; // Set the field type to 'reference'
        gr.reference = 'sys_user_group'; // Set the reference table
        gr.update();
        gs.print('Field type changed to reference for ' + fieldName + ' on table ' + tableName);
    } else {
        gs.print('Field not found');
    }
})();

# Define the access token and endpoint

$endpoint = "https://cdcrnonprod.servicenowservices.com/api/g_cdo2/successfactors"
$accessToken = "vfvtjbLQj_HQnAD9Db9M4bsjEZcqRK6vwuRcMRB4JVP2bUPuR8UhxXnEyw2XV8MDgSLRDfOeDqdOUhAZGz97Dw"

# Define the message body
$body = @{
    requested_for = "Srinivasan Parthasarathy"
    requested_by = "Srinivasan Parthasarathy"
    requester_location = "EIS 1940-Enterprise Information Services-HQ000006"
    requester_phone = "818-357-0507"
    onboarding_type = "New Hire"
    employee_full_name = "Joe Newhire"
    start_date = "2024-08-01"
    end_date = ""
    employee_pernr = "1"
    employee_former_work_location = ""
    employee_former_job_title = ""
    employee_work_location = "EIS 1940-Enterprise Information Services-HQ000006"
    employee_job_title = "Account Clerk II"
    employee_s_direct_supervisor = "Sukhjit Badwal"
    soms = ""
    erms = ""
    obiee_reporting = ""
    hca = ""
    leads = ""
    none = "true"
    distribution_lists_or_security_groups_access = ""
    teams_phone_number_needed = "yes"
    additional_information = ""
} | ConvertTo-Json

# Make the POST request
$response = Invoke-RestMethod -Uri $endpoint -Method Post -Headers @{
    "Authorization" = "Bearer $accessToken"
    "Content-Type" = "application/json"
} -Body $body

# Output the response
$response

# Define the variables
$clientId = "YOUR_CLIENT_ID"
$clientSecret = "YOUR_CLIENT_SECRET"
$username = "YOUR_USERNAME"
$password = "YOUR_PASSWORD"

# Encode the client ID and secret
$encodedAuth = [Convert]::ToBase64String([Text.Encoding]::ASCII.GetBytes("$clientId:$clientSecret"))

# Define the token endpoint URL
$tokenUrl = "https://$instanceName.service-now.com/oauth_token.do"

# Create the body for the POST request
$body = @{
    grant_type = "password"
    username = $username
    password = $password
}

# Convert the body to a URL-encoded string
$bodyEncoded = [System.Web.HttpUtility]::ParseQueryString([System.String]::Empty)
$body.GetEnumerator() | ForEach-Object { $bodyEncoded.Add($_.Key, $_.Value) }
$bodyString = $bodyEncoded.ToString()

# Define the headers
$headers = @{
    "Authorization" = "Basic $encodedAuth"
    "Content-Type"  = "application/x-www-form-urlencoded"
}

# Make the POST request to get the tokens
$response = Invoke-RestMethod -Uri $tokenUrl -Method Post -Headers $headers -Body $bodyString

# Output the tokens
$accessToken = $response.access_token
$refreshToken = $response.refresh_token

Write-Host "Access Token: $accessToken"
Write-Host "Refresh Token: $refreshToken"

# Define the variables
$clientId = "YOUR_CLIENT_ID"
$clientSecret = "YOUR_CLIENT_SECRET"
$refreshToken = "YOUR_REFRESH_TOKEN"

# Encode the client ID and secret
$encodedAuth = [Convert]::ToBase64String([Text.Encoding]::ASCII.GetBytes("$clientId:$clientSecret"))

# Define the token endpoint URL
$tokenUrl = "https://$instanceName.service-now.com/oauth_token.do"

# Create the body for the POST request
$body = @{
    grant_type = "refresh_token"
    refresh_token = $refreshToken
}

# Convert the body to a URL-encoded string
$bodyString = ($body.GetEnumerator() | ForEach-Object { "$($_.Key)=$([System.Net.WebUtility]::UrlEncode($_.Value))" }) -join "&"

# Define the headers
$headers = @{
    "Authorization" = "Basic $encodedAuth"
    "Content-Type"  = "application/x-www-form-urlencoded"
}

# Make the POST request to get the new access token
$response = Invoke-RestMethod -Uri $tokenUrl -Method Post -Headers $headers -Body $bodyString

# Output the new access token
$accessToken = $response.access_token

Write-Host "New Access Token: $accessToken"




(function process(/*RESTAPIRequest*/ request, /*RESTAPIResponse*/ response) {
    // Extract parameters from the request
    var params = request.body.data;
    var itemName = params.itemName;
    var itemDescription = params.itemDescription;
    var itemPrice = params.itemPrice;

    // Create a new cart
    var cart = new Cart();
    var cartItem = cart.addItem('YOUR_CATALOG_ITEM_SYS_ID'); // Replace with your catalog item sys_id

    // Set variables for the catalog item
    cart.setVariable(cartItem, 'itemName', itemName);
    cart.setVariable(cartItem, 'itemDescription', itemDescription);
    cart.setVariable(cartItem, 'itemPrice', itemPrice);

    // Submit the cart and generate the RITM
    var cartId = cart.placeOrder();
    var ritm = new GlideRecord('sc_req_item');
    ritm.addQuery('request', cartId);
    ritm.query();

    if (ritm.next()) {
        // Set the response object
        var responseData = {
            status: 'success',
            message: 'Catalog item and RITM created successfully',
            ritmNumber: ritm.getValue('number'),
            ritmUrl: gs.getProperty('glide.servlet.uri') + 'sc_req_item.do?sys_id=' + ritm.getUniqueValue()
        };
        response.setStatus(201); // Created
        response.setBody(responseData);
    } else {
        // Handle the error case for RITM creation
        var errorData = {
            status: 'error',
            message: 'Failed to create RITM'
        };
        response.setStatus(500); // Internal Server Error
        response.setBody(errorData);
    }
})(request, response);

// Function to get sys_id based on display value
function getSysIdByDisplayValue(tableName, displayValue, displayField) {
    var gr = new GlideRecord(tableName);
    gr.addQuery(displayField, displayValue);
    gr.query();
    if (gr.next()) {
        return gr.sys_id.toString();
    } else {
        return null; // No record found
    }
}

// Example usage
var tableName = 'cmdb_ci'; // Replace with your referenced table name
var displayValue = 'My CI Name'; // Replace with your display value
var displayField = 'name'; // Replace with your display field

var sysId = getSysIdByDisplayValue(tableName, displayValue, displayField);

if (sysId) {
    var gr = new GlideRecord('sc_req_item'); // Replace with your catalog item table
    if (gr.get('sys_id_of_catalog_item')) { // Replace with the sys_id of the catalog item
        gr.u_reference_field = sysId; // Replace with your reference field name
        gr.update();
        gs.info('Reference field set successfully');
    } else {
        gs.info('Catalog item not found');
    }
} else {
    gs.info('Referenced record not found');
}

(function process(/*RESTAPIRequest*/ request, /*RESTAPIResponse*/ response) {

    // implement resource here
	var arr = [];
	var params = request.pathParams;
	var user_sys_id = params.user_sys_id;
	var sarecords = params.records;
	gs.log("User: " + user_sys_id);
	gs.log("Records: " + sarecords);
	response.setBody({'User': user_sys_id, 'Records': sarecords});	
	
	var cartId = GlideGuid.generate(null);
	var cart = new Cart(cartId);

	//add your requested item to the cart by sys_id of the catalog item
	var item = cart.addItem('ad4c3cef1baedd10f367fe6edd4bcbc1', 1);

	//fill in the variables on the request item form
	cart.setVariable(item,"requested_by", user_sys_id); 
	cart.setVariable(item,"what_are_the_service_acccount_that_need_to_be_certified", sarecords);
	var rc = cart.placeOrder();

})(request, response);


